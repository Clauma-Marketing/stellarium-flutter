<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Stellarium</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #000;
      touch-action: none;
    }
    #stellarium-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      touch-action: none;
    }
    /* Custom label is now rendered natively by the engine */
    #custom-label {
      display: none;
    }
    /* Direction arrow is now rendered inside the engine via pointer.c */
  </style>
</head>
<body>
  <canvas id="stellarium-canvas"></canvas>
  <div id="custom-label"></div>

  <!-- Direction arrow is now rendered inside the engine via pointer.c -->

  <script src="stellarium-web-engine.js"></script>
  <script>
    // Global state
    window.stellarium = null;
    window.stellariumReady = false;
    window.stelModule = null;  // Reference to Emscripten Module for touch forwarding

    // Send message to Flutter via webview_flutter's JavaScript channel
    function sendToFlutter(type, data) {
      if (window.FlutterChannel) {
        FlutterChannel.postMessage(JSON.stringify({
          type: type,
          data: data
        }));
      }
    }

    // Network request debugging (enabled when loaded with ?debugNet=1)
    (function installNetworkDebug() {
      try {
        const params = new URLSearchParams(window.location.search);
        if (!params.has('debugNet')) return;

        const log = (event, extra) => {
          try {
            sendToFlutter('network', Object.assign({
              event: event,
              time: Date.now()
            }, extra || {}));
          } catch (e) {
            // Ignore logging failures
          }
        };

        // Patch fetch to log requests/responses
        if (window.fetch) {
          const originalFetch = window.fetch;
          window.fetch = function(input, init) {
            let url = null;
            let method = 'GET';
            try {
              url = (typeof input === 'string') ? input : (input && input.url);
              method = (init && init.method) || (input && input.method) || 'GET';
            } catch (e) {}
            return originalFetch.apply(this, arguments)
              .then(res => {
                if (res.status !== 200) {
                  log('fetchResponse', { url: res.url, status: res.status, ok: res.ok, method: method });
                }
                return res;
              })
              .catch(err => {
                log('fetchError', { url: url, method: method, error: String(err) });
                throw err;
              });
          };
        }

        // Patch XMLHttpRequest to log requests/responses
        if (window.XMLHttpRequest) {
          const origOpen = XMLHttpRequest.prototype.open;
          const origSend = XMLHttpRequest.prototype.send;
          XMLHttpRequest.prototype.open = function(method, url) {
            try {
              this.__netDebug = { method: method, url: url };
            } catch (e) {}
            return origOpen.apply(this, arguments);
          };
          XMLHttpRequest.prototype.send = function(body) {
            try {
              this.addEventListener('loadend', () => {
                const status = this.status;
                if (status !== 200) {
                  const info = this.__netDebug || {};
                  log('xhrResponse', {
                    url: this.responseURL || info.url,
                    method: info.method,
                    status: status
                  });
                }
              });
            } catch (e) {}
            return origSend.apply(this, arguments);
          };
        }

        // Log resource load failures (scripts, images, wasm, css, etc.)
        window.addEventListener('error', function(e) {
          try {
            const t = e && e.target;
            const url = t && (t.src || t.href);
            if (url) {
              log('resourceError', { url: url, tag: t.tagName });
            }
          } catch (err) {}
        }, true);

        log('installed', { userAgent: navigator.userAgent });
        console.log('Stellarium network debug enabled');
      } catch (e) {
        console.log('Network debug install error', e);
      }
    })();

    // Convert JavaScript Date to Modified Julian Date (MJD)
    // Uses local time values to match Flutter's convention
    function dateToMjd(date) {
      var y = date.getFullYear();
      var m = date.getMonth() + 1; // JavaScript months are 0-based
      var d = date.getDate() +
              date.getHours() / 24.0 +
              date.getMinutes() / 1440.0 +
              date.getSeconds() / 86400.0 +
              date.getMilliseconds() / 86400000.0;

      var a = Math.floor((14 - m) / 12);
      var yAdj = y + 4800 - a;
      var mAdj = m + 12 * a - 3;

      var jd = d +
               Math.floor((153 * mAdj + 2) / 5) +
               365 * yAdj +
               Math.floor(yAdj / 4) -
               Math.floor(yAdj / 100) +
               Math.floor(yAdj / 400) -
               32045;

      // Subtract 2400001.0 to shift from noon to midnight epoch
      return jd - 2400001.0;
    }

    // Initialize Stellarium
    function initStellarium() {
      const canvas = document.getElementById('stellarium-canvas');

      // Resize canvas
      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
      }

      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      // Create Stellarium engine
      StelWebEngine({
        canvas: canvas,
        wasmFile: 'stellarium-web-engine.wasm',
        onReady: function(stel) {
          window.stellarium = stel;
          window.stellariumReady = true;

          // Capture Module reference for touch forwarding
          // Module is created by Emscripten and has _core_on_mouse
          if (typeof Module !== 'undefined') {
            window.stelModule = Module;
          } else if (typeof window.Module !== 'undefined') {
            window.stelModule = window.Module;
          } else if (stel._module) {
            window.stelModule = stel._module;
          } else if (stel.Module) {
            window.stelModule = stel.Module;
          } else {
            // Search for _core_on_mouse in window properties
            for (var key in window) {
              if (window[key] && typeof window[key]._core_on_mouse === 'function') {
                window.stelModule = window[key];
                break;
              }
            }
          }

          const core = stel.core;
          const baseUrl = 'https://data.star-register.com/';

	          // Add data sources
	          core.stars.addDataSource({ url: baseUrl + 'surveys/stars/v1' });
	          core.stars.addDataSource({
	            url: baseUrl + 'surveys/gaia/v1',
	            key: 'gaia'
	          });
	          core.skycultures.addDataSource({
	            url: baseUrl + 'skycultures/v2/western',
	            key: 'western'
	          });
	          core.dsos.addDataSource({ url: baseUrl + 'surveys/dso/v1' });
	          core.milkyway.addDataSource({ url: baseUrl + 'surveys/milkyway/v1' });
	          core.dss.addDataSource({ url: baseUrl + 'surveys/dss/v1' });
	          core.minor_planets.addDataSource({
	            url: baseUrl + 'mpc/v1/mpcorb.dat',
	            key: 'mpc_asteroids'
	          });
	          core.comets.addDataSource({
	            url: baseUrl + 'mpc/v1/CometEls.txt?v=2019-12-17',
	            key: 'mpc_comets'
	          });
	          core.satellites.addDataSource({
	            url: baseUrl + 'skysources/v1/tle_satellite.jsonl.gz?v=2019-09-16',
	            key: 'jsonl/sat'
	          });
	          core.planets.addDataSource({
	            url: baseUrl + 'surveys/sso/moon/v1',
	            key: 'moon'
	          });
	          core.planets.addDataSource({
	            url: baseUrl + 'surveys/sso/sun/v1',
	            key: 'sun'
	          });
	          core.planets.addDataSource({
	            url: baseUrl + 'surveys/sso/callisto/v1',
	            key: 'callisto'
	          });
	          core.planets.addDataSource({
	            url: baseUrl + 'surveys/sso/default/v1',
	            key: 'default'
	          });
	          core.planets.addDataSource({
	            url: baseUrl + 'surveys/sso/europa/v1',
	            key: 'europa'
	          });
	          core.planets.addDataSource({
	            url: baseUrl + 'surveys/sso/ganymede/v1',
	            key: 'ganymede'
	          });
	          core.planets.addDataSource({
	            url: baseUrl + 'surveys/sso/io/v1',
	            key: 'io'
	          });
	          core.planets.addDataSource({
	            url: baseUrl + 'surveys/sso/jupiter/v1',
	            key: 'jupiter'
	          });
	          core.planets.addDataSource({
	            url: baseUrl + 'surveys/sso/mars/v1',
	            key: 'mars'
	          });
	          core.planets.addDataSource({
	            url: baseUrl + 'surveys/sso/mercury/v1',
	            key: 'mercury'
	          });
	          core.planets.addDataSource({
	            url: baseUrl + 'surveys/sso/moon-normal/v1',
	            key: 'moon-normal'
	          });
	          core.planets.addDataSource({
	            url: baseUrl + 'surveys/sso/neptune/v1',
	            key: 'neptune'
	          });
	          core.planets.addDataSource({
	            url: baseUrl + 'surveys/sso/saturn/v1',
	            key: 'saturn'
	          });
	          core.planets.addDataSource({
	            url: baseUrl + 'surveys/sso/uranus/v1',
	            key: 'uranus'
	          });
	          core.planets.addDataSource({
	            url: baseUrl + 'surveys/sso/venus/v1',
	            key: 'venus'
	          });
	          core.landscapes.addDataSource({
	            url: baseUrl + 'landscapes/v1/guereins',
	            key: 'guereins'
	          });

	          // Constellation art in the engine is quite subtle by default.
	          // Increase illustration brightness/opacity so the artwork is clearer.
	          if (core.constellations && core.constellations.illustrations_bscale != null) {
	            core.constellations.illustrations_bscale = 5.8;
	          }

	          // Default location (New York)
	          stel.observer.longitude = -74.0060 * stel.D2R;
	          stel.observer.latitude = 40.7128 * stel.D2R;

          // Set time to current time (now) and enable real-time progression
          var now = new Date();
          var mjd = dateToMjd(now);
          stel.observer.utc = mjd;
          // Set time speed to 1.0 for real-time progression
          if (stel.core) {
            stel.core.time_speed = 1.0;
          }
          console.log('Set initial time to now:', now.toISOString(), 'MJD:', mjd);

          // Set up time + fov change listener for explicit changes
          var lastUtc = stel.observer.utc;
          var lastFov = stel.observer.fov;
          stel.change(function(obj, attr) {
            // Check if observer UTC changed
            if (attr === 'utc' || (obj === stel.observer && stel.observer.utc !== lastUtc)) {
              lastUtc = stel.observer.utc;
              sendToFlutter('timeChanged', { utc: lastUtc });
            }

            // Check if FOV (zoom) changed
            if (attr === 'fov' || (obj === stel.observer && stel.observer.fov !== lastFov)) {
              const newFov = stel.observer.fov;
              if (Math.abs(newFov - lastFov) > 1e-4) { // ~0.006°
                lastFov = newFov;
                const fovDeg = lastFov * stel.R2D;
                console.log('fovChanged:', fovDeg.toFixed(2) + '°');
                sendToFlutter('fovChanged', { fov: fovDeg });
              }
            }
          });

          // Set up periodic time update for real-time progression
          // Check every second if time or fov has changed (due to real-time simulation)
          setInterval(function() {
            if (stel.observer.utc !== lastUtc) {
              lastUtc = stel.observer.utc;
              sendToFlutter('timeChanged', { utc: lastUtc });
            }
            if (Math.abs(stel.observer.fov - lastFov) > 1e-4) {
              lastFov = stel.observer.fov;
              const fovDeg = lastFov * stel.R2D;
              console.log('fovChanged(interval):', fovDeg.toFixed(2) + '°');
              sendToFlutter('fovChanged', { fov: fovDeg });
            }
          }, 1000);

          // Notify Flutter
          sendToFlutter('ready', {});
          // Send initial FOV so Flutter can scale gyro sensitivity
          try {
            const fovDeg = stel.observer.fov * stel.R2D;
            console.log('fovChanged(initial):', fovDeg.toFixed(2) + '°');
            sendToFlutter('fovChanged', { fov: fovDeg });
          } catch (e) {}

          console.log('Stellarium ready');
        }
      });
    }

    // API for Flutter to call
    window.stellariumAPI = {
      setLocation: function(lat, lon, alt) {
        if (!window.stellarium) return;
        const stel = window.stellarium;
        stel.observer.latitude = lat * stel.D2R;
        stel.observer.longitude = lon * stel.D2R;
        if (alt !== undefined) stel.observer.elevation = alt;
      },

      setTime: function(mjd) {
        if (!window.stellarium) return;
        window.stellarium.observer.utc = mjd;
      },

      setTimeSpeed: function(speed) {
        if (!window.stellarium || !window.stellarium.core) return;
        window.stellarium.core.time_speed = speed;
        console.log('Time speed set to:', speed);
      },

      getTimeSpeed: function() {
        if (!window.stellarium || !window.stellarium.core) return 1.0;
        return window.stellarium.core.time_speed || 1.0;
      },

      setFov: function(fovDeg, duration) {
        if (!window.stellarium) return;
        const fovRad = fovDeg * window.stellarium.D2R;
        window.stellarium.zoomTo(fovRad, duration || 1.0);
      },

      setSetting: function(key, value) {
        if (!window.stellarium) return;
        const core = window.stellarium.core;

        try {
          switch(key) {
            case 'constellationsLines':
              core.constellations.lines_visible = value;
              break;
            case 'constellationsLabels':
              core.constellations.labels_visible = value;
              break;
            case 'constellationsArt':
              core.constellations.images_visible = value;
              break;
            case 'atmosphere':
              core.atmosphere.visible = value;
              break;
            case 'landscape':
              core.landscapes.visible = value;
              break;
            case 'landscapeFog':
              core.landscapes.fog_visible = value;
              break;
            case 'milkyWay':
              core.milkyway.visible = value;
              break;
            case 'dss':
              core.dss.visible = value;
              break;
            case 'stars':
              core.stars.visible = value;
              break;
            case 'planets':
              core.planets.visible = value;
              break;
            case 'dsos':
              core.dsos.visible = value;
              break;
            case 'satellites':
              if (core.satellites) core.satellites.visible = value;
              break;
            case 'gridAzimuthal':
              core.lines.azimuthal.visible = value;
              break;
            case 'gridEquatorial':
              core.lines.equatorial_jnow.visible = value;
              break;
            case 'gridEquatorialJ2000':
              core.lines.equatorial.visible = value;
              break;
            case 'lineMeridian':
              core.lines.meridian.visible = value;
              break;
            case 'lineEcliptic':
              core.lines.ecliptic.visible = value;
              break;
          }
        } catch(e) {
          console.error('setSetting error:', key, e);
        }
      },

      getObserver: function() {
        if (!window.stellarium) return null;
        const stel = window.stellarium;
        const obs = stel.observer;
        return {
          latitude: obs.latitude * stel.R2D,
          longitude: obs.longitude * stel.R2D,
          altitude: obs.elevation,
          azimuth: obs.azimuth * stel.R2D,
          elevation: obs.altitude * stel.R2D,
          fov: obs.fov * stel.R2D,
          utc: obs.utc
        };
      },

      search: function(query) {
        if (!window.stellarium) return Promise.resolve(null);
        try {
          // Try different name formats
          var obj = window.stellarium.getObj('NAME ' + query);
          if (!obj) obj = window.stellarium.getObj(query);
          if (!obj) return Promise.resolve(null);
          return Promise.resolve({
            name: query,
            type: obj.type || 'unknown'
          });
        } catch(e) {
          console.error('search error:', e);
          return Promise.resolve(null);
        }
      },

      pointAt: function(name, duration) {
        if (!window.stellarium) return;
        try {
          const stel = window.stellarium;
          // Try different name formats
          var obj = stel.getObj('NAME ' + name);
          if (!obj) obj = stel.getObj(name);
          if (obj) {
            // Select the object (shows crosshair marker)
            stel.core.selection = obj;
            console.log('Selected:', name);

            // Get current FOV to calculate offset
            const fov = stel.observer.fov || (60 * Math.PI / 180);

            // Set view_offset_alt to move star up on screen
            // Positive offset = star appears higher on screen
            const offset = fov * 0.35;
            stel.observer.view_offset_alt = offset;
            console.log('Set view_offset_alt to ' + (offset * 180 / Math.PI).toFixed(1) + '° (FOV: ' + (fov * 180 / Math.PI).toFixed(1) + '°)');

            // Point and lock to the object (with offset applied)
            stel.pointAndLock(obj, duration || 1.0);
            console.log('Pointing at:', name, '(with offset)');

            // Send object selection to Flutter so info sheet can be shown
            // Use designations() method (not property) to get names
            const names = typeof obj.designations === 'function' ? obj.designations() : (obj.names || [name]);
            const info = {
              name: (names && names.length > 0) ? names[0] : name,
              names: names || [name],
              type: obj.type || 'unknown',
              vmag: obj.vmag,
              ra: obj.ra !== undefined ? obj.ra * stel.R2D : null,
              dec: obj.de !== undefined ? obj.de * stel.R2D : null,
              distance: obj.distance
            };
            console.log('pointAt: sending objectSelected to Flutter:', info);
            sendToFlutter('objectSelected', info);
          } else {
            console.log('Object not found:', name);
          }
        } catch(e) {
          console.error('pointAt error:', e);
        }
      },

      // Select an object without moving the camera (for gyroscope mode)
      selectObject: function(name) {
        if (!window.stellarium) return;
        try {
          const stel = window.stellarium;
          // Try different name formats
          var obj = stel.getObj('NAME ' + name);
          if (!obj) obj = stel.getObj(name);
          if (obj) {
            // Select the object (shows crosshair marker) without moving camera
            stel.core.selection = obj;
            console.log('Selected (no camera move):', name);

            // Send object selection to Flutter so info sheet can be shown
            const names = typeof obj.designations === 'function' ? obj.designations() : (obj.names || [name]);
            const info = {
              name: (names && names.length > 0) ? names[0] : name,
              names: names || [name],
              type: obj.type || 'unknown',
              vmag: obj.vmag,
              ra: obj.ra !== undefined ? obj.ra * stel.R2D : null,
              dec: obj.de !== undefined ? obj.de * stel.R2D : null,
              distance: obj.distance
            };
            console.log('selectObject: sending objectSelected to Flutter:', info);
            sendToFlutter('objectSelected', info);
          } else {
            console.log('Object not found:', name);
          }
        } catch(e) {
          console.error('selectObject error:', e);
        }
      },

      lookAt: function(azimuthDeg, altitudeDeg, duration) {
        if (!window.stellarium) return;
        try {
          const stel = window.stellarium;
          const azRad = azimuthDeg * stel.D2R;
          const altRad = altitudeDeg * stel.D2R;
          // Convert spherical to cartesian direction vector
          var pos = stel.s2c(azRad, altRad);
          stel.lookAt(pos, duration || 0);
        } catch(e) {
          console.error('lookAt error:', e);
        }
      },

      lookAtRadians: function(azimuthRad, altitudeRad, duration) {
        if (!window.stellarium) {
          console.log('lookAtRadians: stellarium not ready');
          return;
        }
        try {
          const stel = window.stellarium;
          // Convert spherical (azimuth, altitude) to cartesian direction vector
          var pos = stel.s2c(azimuthRad, altitudeRad);
          stel.lookAt(pos, duration || 0);
        } catch(e) {
          console.error('lookAtRadians error:', e);
        }
      },

      setGyroscopeEnabled: function(enabled) {
        window.gyroscopeEnabled = enabled;
        // Set the engine's gyroscope_mode property for native arrow rendering
        if (window.stellarium && window.stellarium.core) {
          window.stellarium.core.gyroscope_mode = enabled;
        }
        console.log('Gyroscope mode:', enabled ? 'enabled' : 'disabled');
      },

      setTouchEnabled: function(enabled) {
        window.touchEnabled = enabled;
        console.log('Touch handling:', enabled ? 'enabled' : 'disabled');
      },

      // Touch events forwarded from Flutter (bypasses native WebView touch handling)
      // Track active touches for multi-finger gesture detection
      _activeTouches: new Set(),

      onTouchStart: function(id, x, y) {
        this._activeTouches.add(id);
        if (window.stelModule && window.stelModule._core_on_mouse) {
          window.stelModule._core_on_mouse(id, 1, x, y, 1);
          // Track for tap detection
          window._touchStartX = x;
          window._touchStartY = y;
          window._touchStartTime = Date.now();
          window._touchId = id;
        }
      },

      onTouchMove: function(id, x, y) {
        // Allow moves if gyroscope disabled OR if 2+ fingers (pinch-to-zoom)
        const allowMove = !window.gyroscopeEnabled || this._activeTouches.size >= 2;
        if (allowMove && window.stelModule && window.stelModule._core_on_mouse) {
          window.stelModule._core_on_mouse(id, -1, x, y, 1);
        }
      },

      onTouchEnd: function(id, x, y) {
        this._activeTouches.delete(id);
        if (window.stelModule && window.stelModule._core_on_mouse) {
          // Always send touch end - MUST use buttons=1 for engine to process (movements.c checks buttons==1)
          window.stelModule._core_on_mouse(id, 0, x, y, 1);

          // Check if this was a tap
          const dx = Math.abs(x - (window._touchStartX || 0));
          const dy = Math.abs(y - (window._touchStartY || 0));
          const duration = Date.now() - (window._touchStartTime || 0);
          const TAP_THRESHOLD = 15;
          const TAP_MAX_DURATION = 300;

          if (dx < TAP_THRESHOLD && dy < TAP_THRESHOLD && duration < TAP_MAX_DURATION) {
            console.log('Flutter-forwarded tap detected at:', x, y);
            if (window.gyroscopeEnabled) {
              const info = stellariumAPI.selectForGuidance(x, y);
              if (info && info.name) {
                sendToFlutter('objectSelected', info);
              }
            } else {
              // Normal tap - wait for engine to process
              requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                  const info = stellariumAPI.getSelectedObjectInfo();
                  if (info && info.name && info.name !== 'Unknown') {
                    sendToFlutter('objectSelected', info);
                  }
                });
              });
            }
          }
        }
      },

      // Get info about selected object
      getSelectedObjectInfo: function() {
        if (!window.stellarium) return null;
        try {
          const stel = window.stellarium;
          const selection = stel.core.selection;
          if (!selection) return null;

          // Use designations() method (not property) to get names
          const names = typeof selection.designations === 'function' ? selection.designations() : (selection.names || []);
          const info = {
            name: (names && names.length > 0) ? names[0] : 'Unknown',
            names: names || [],
            type: selection.type || 'unknown',
            vmag: selection.vmag,
            ra: selection.ra * stel.R2D,
            dec: selection.de * stel.R2D,
            distance: selection.distance
          };
          return info;
        } catch(e) {
          console.error('getSelectedObjectInfo error:', e);
          return null;
        }
      },

      // Set a custom label for the currently selected star
      // This uses the native engine API to render the label in the sky view
      setCustomLabel: function(label) {
        if (!window.stellarium) {
          console.log('setCustomLabel: stellarium not ready');
          return;
        }

        const stel = window.stellarium;

        if (label && label.trim()) {
          // Use the native engine API to set the custom label
          stel.setSelectionCustomLabel(label);
          window.currentCustomLabel = label;
          console.log('Custom label set (native):', label);
        } else {
          this.clearCustomLabel();
        }
      },

      // Clear the custom label
      clearCustomLabel: function() {
        if (window.stellarium) {
          window.stellarium.setSelectionCustomLabel('');
        }
        window.currentCustomLabel = null;
        console.log('Custom label cleared');
      },

      // Add a persistent label for a star (shown without selection)
      addPersistentLabel: function(identifier, label) {
        if (!window.stellarium) {
          console.log('addPersistentLabel: stellarium not ready');
          return;
        }
        window.stellarium.addPersistentLabel(identifier, label);
        console.log('Persistent label added:', identifier, '->', label);
      },

      // Remove a persistent label for a star
      removePersistentLabel: function(identifier) {
        if (!window.stellarium) {
          console.log('removePersistentLabel: stellarium not ready');
          return;
        }
        window.stellarium.removePersistentLabel(identifier);
        console.log('Persistent label removed:', identifier);
      },

      // Clear all persistent labels
      clearPersistentLabels: function() {
        if (!window.stellarium) {
          console.log('clearPersistentLabels: stellarium not ready');
          return;
        }
        window.stellarium.clearPersistentLabels();
        console.log('All persistent labels cleared');
      },

      // Select object at screen coordinates
      selectAtPosition: function(x, y) {
        if (!window.stellarium) return null;
        try {
          const stel = window.stellarium;

          // Send click event to engine to trigger object selection
          // This mimics a mouse click at the position
          if (window.stelModule && window.stelModule._core_on_mouse) {
            // Mouse down (action=1) then up (action=0) = click
            // MUST use buttons=1 for both events (movements.c checks buttons==1)
            window.stelModule._core_on_mouse(99, 1, x, y, 1); // Use ID 99 for selection clicks
            window.stelModule._core_on_mouse(99, 0, x, y, 1);
          }

          // Read the selection that was set by the click
          const selection = stel.core.selection;
          console.log('selectAtPosition: selection =', selection, 'at', x, y);
          if (!selection) return null;

          // Use designations() method (not property) to get names
          const names = typeof selection.designations === 'function' ? selection.designations() : (selection.names || []);
          const info = {
            name: (names && names.length > 0) ? names[0] : 'Unknown',
            names: names || [],
            type: selection.type || 'unknown',
            vmag: selection.vmag,
            ra: selection.ra !== undefined ? selection.ra * stel.R2D : null,
            dec: selection.de !== undefined ? selection.de * stel.R2D : null,
            distance: selection.distance
          };
          console.log('selectAtPosition: returning info:', info);
          return info;
        } catch(e) {
          console.error('selectAtPosition error:', e);
          return null;
        }
      },

      // Select object at screen coordinates (async version - waits for engine to process)
      selectAtPositionAsync: function(x, y) {
        return new Promise((resolve) => {
          if (!window.stellarium) {
            resolve(null);
            return;
          }
          try {
            const stel = window.stellarium;

            // Send click event to engine to trigger object selection
            // MUST use buttons=1 for both events (movements.c checks buttons==1)
            if (window.stelModule && window.stelModule._core_on_mouse) {
              window.stelModule._core_on_mouse(99, 1, x, y, 1);
              window.stelModule._core_on_mouse(99, 0, x, y, 1);
            }

            // Wait for next frame for engine to process the click
            requestAnimationFrame(() => {
              const selection = stel.core.selection;
              console.log('selectAtPositionAsync: selection =', selection);
              if (!selection) {
                resolve(null);
                return;
              }

              // Use designations() method (not property) to get names
              const names = typeof selection.designations === 'function' ? selection.designations() : (selection.names || []);
              const info = {
                name: (names && names.length > 0) ? names[0] : 'Unknown',
                names: names || [],
                type: selection.type || 'unknown',
                vmag: selection.vmag,
                ra: selection.ra !== undefined ? selection.ra * stel.R2D : null,
                dec: selection.de !== undefined ? selection.de * stel.R2D : null,
                distance: selection.distance
              };
              resolve(info);
            });
          } catch(e) {
            console.error('selectAtPositionAsync error:', e);
            resolve(null);
          }
        });
      },

      // Start gyroscope guidance to a star by name
      startGuidance: function(name) {
        if (!window.stellarium) return false;
        try {
          const stel = window.stellarium;
          var obj = stel.getObj('NAME ' + name);
          if (!obj) obj = stel.getObj(name);
          if (obj) {
            // Set selection (shows crosshair marker) without changing view
            stel.core.selection = obj;
            // Start gyroscope guidance
            startGyroscopeGuidance(obj, name);
            return true;
          }
          return false;
        } catch(e) {
          console.error('startGuidance error:', e);
          return false;
        }
      },

      // Stop gyroscope guidance
      stopGuidance: function() {
        stopGyroscopeGuidance();
        // Clear selection as well
        if (window.stellarium) {
          window.stellarium.core.selection = null;
        }
      },

      // Set star tracking (24-hour path) visibility
      setStarTrackVisible: function(visible) {
        if (!window.stellarium || !window.stellarium.core) {
          console.log('setStarTrackVisible: stellarium not ready');
          return false;
        }
        try {
          const core = window.stellarium.core;
          // Access the star_track module
          if (core.star_track) {
            core.star_track.visible = visible;
            console.log('Star track visibility set to:', visible);
            return true;
          } else {
            console.log('setStarTrackVisible: star_track module not found in core');
            // List available modules for debugging
            console.log('Available core properties:', Object.keys(core));
            return false;
          }
        } catch(e) {
          console.error('setStarTrackVisible error:', e);
          return false;
        }
      },

      // Select object at position in gyroscope mode (no view change)
      selectForGuidance: function(x, y) {
        if (!window.stellarium) return null;
        try {
          const stel = window.stellarium;

          // Send click event to engine to trigger object selection
          // MUST use buttons=1 for both events (movements.c checks buttons==1)
          if (window.stelModule && window.stelModule._core_on_mouse) {
            window.stelModule._core_on_mouse(99, 1, x, y, 1);
            window.stelModule._core_on_mouse(99, 0, x, y, 1);
          }

          // Read the selection
          const selection = stel.core.selection;
          if (!selection) return null;

          // Use designations() method (not property) to get names
          const names = typeof selection.designations === 'function' ? selection.designations() : (selection.names || []);
          const name = (names && names.length > 0) ? names[0] : 'Unknown';

          // Start guidance to selected object
          startGyroscopeGuidance(selection, name);

          const info = {
            name: name,
            names: names || [],
            type: selection.type || 'unknown',
            vmag: selection.vmag,
            ra: selection.ra !== undefined ? selection.ra * stel.R2D : null,
            dec: selection.de !== undefined ? selection.de * stel.R2D : null,
            distance: selection.distance
          };
          return info;
        } catch(e) {
          console.error('selectForGuidance error:', e);
          return null;
        }
      }
    };

    // Gyroscope mode flag - when true, disable touch panning
    window.gyroscopeEnabled = false;

    // Touch enabled flag - when false, ignore ALL touch events
    window.touchEnabled = true;

    // Direction arrow is now rendered natively in the engine (pointer.c)
    // when gyroscope_mode is enabled and selection is off-screen.
    // These functions are kept for API compatibility but do minimal work.

    // Start tracking a target for gyroscope guidance (now handled by engine)
    function startGyroscopeGuidance(obj, name) {
      console.log('Gyroscope guidance started for:', name);
      // Arrow is now rendered by the engine's pointer module
    }

    // Stop gyroscope guidance (now handled by engine)
    function stopGyroscopeGuidance() {
      console.log('Gyroscope guidance stopped');
      // Arrow is now rendered by the engine's pointer module
    }

    // NOTE: Native touch handling is now done in canvas.js (stellarium-web-engine)
    // with UI bounds filtering. These document-level handlers are disabled to
    // prevent double-processing of touch events.
    // The canvas.js handlers check window.uiBounds before processing any touch.

    // Start
    if (typeof StelWebEngine !== 'undefined') {
      initStellarium();
    } else {
      window.addEventListener('load', function() {
        if (typeof StelWebEngine !== 'undefined') {
          initStellarium();
        } else {
          sendToFlutter('error', { message: 'StelWebEngine not loaded' });
        }
      });
    }
  </script>
</body>
</html>
