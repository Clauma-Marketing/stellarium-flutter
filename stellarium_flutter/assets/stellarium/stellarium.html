<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Stellarium</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #000;
      touch-action: none;
    }
    #stellarium-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      touch-action: none;
    }
    /* Custom label is now rendered natively by the engine */
    #custom-label {
      display: none;
    }
    /* Direction arrow is now rendered inside the engine via pointer.c */
  </style>
</head>
<body>
  <canvas id="stellarium-canvas"></canvas>
  <div id="custom-label"></div>

  <!-- Direction arrow is now rendered inside the engine via pointer.c -->

  <script src="stellarium-web-engine.js"></script>
  <script>
    // Global state
    window.stellarium = null;
    window.stellariumReady = false;
    window.stelModule = null;  // Reference to Emscripten Module for touch forwarding

    // Send message to Flutter via webview_flutter's JavaScript channel
    function sendToFlutter(type, data) {
      if (window.FlutterChannel) {
        FlutterChannel.postMessage(JSON.stringify({
          type: type,
          data: data
        }));
      }
    }

    // Network request debugging (enabled when loaded with ?debugNet=1)
    (function installNetworkDebug() {
      try {
        const params = new URLSearchParams(window.location.search);
        if (!params.has('debugNet')) return;

        const log = (event, extra) => {
          try {
            sendToFlutter('network', Object.assign({
              event: event,
              time: Date.now()
            }, extra || {}));
          } catch (e) {
            // Ignore logging failures
          }
        };

        // Patch fetch to log requests/responses
        if (window.fetch) {
          const originalFetch = window.fetch;
          window.fetch = function(input, init) {
            let url = null;
            let method = 'GET';
            try {
              url = (typeof input === 'string') ? input : (input && input.url);
              method = (init && init.method) || (input && input.method) || 'GET';
            } catch (e) {}
            return originalFetch.apply(this, arguments)
              .then(res => {
                if (res.status !== 200) {
                  log('fetchResponse', { url: res.url, status: res.status, ok: res.ok, method: method });
                }
                return res;
              })
              .catch(err => {
                log('fetchError', { url: url, method: method, error: String(err) });
                throw err;
              });
          };
        }

        // Patch XMLHttpRequest to log requests/responses
        if (window.XMLHttpRequest) {
          const origOpen = XMLHttpRequest.prototype.open;
          const origSend = XMLHttpRequest.prototype.send;
          XMLHttpRequest.prototype.open = function(method, url) {
            try {
              this.__netDebug = { method: method, url: url };
            } catch (e) {}
            return origOpen.apply(this, arguments);
          };
          XMLHttpRequest.prototype.send = function(body) {
            try {
              this.addEventListener('loadend', () => {
                const status = this.status;
                if (status !== 200) {
                  const info = this.__netDebug || {};
                  log('xhrResponse', {
                    url: this.responseURL || info.url,
                    method: info.method,
                    status: status
                  });
                }
              });
            } catch (e) {}
            return origSend.apply(this, arguments);
          };
        }

        // Log resource load failures (scripts, images, wasm, css, etc.)
        window.addEventListener('error', function(e) {
          try {
            const t = e && e.target;
            const url = t && (t.src || t.href);
            if (url) {
              log('resourceError', { url: url, tag: t.tagName });
            }
          } catch (err) {}
        }, true);

        log('installed', { userAgent: navigator.userAgent });
        console.log('Stellarium network debug enabled');
      } catch (e) {
        console.log('Network debug install error', e);
      }
    })();

    // Convert JavaScript Date to Modified Julian Date (MJD)
    // Uses local time values to match Flutter's convention
    function dateToMjd(date) {
      var y = date.getFullYear();
      var m = date.getMonth() + 1; // JavaScript months are 0-based
      var d = date.getDate() +
              date.getHours() / 24.0 +
              date.getMinutes() / 1440.0 +
              date.getSeconds() / 86400.0 +
              date.getMilliseconds() / 86400000.0;

      var a = Math.floor((14 - m) / 12);
      var yAdj = y + 4800 - a;
      var mAdj = m + 12 * a - 3;

      var jd = d +
               Math.floor((153 * mAdj + 2) / 5) +
               365 * yAdj +
               Math.floor(yAdj / 4) -
               Math.floor(yAdj / 100) +
               Math.floor(yAdj / 400) -
               32045;

      // Subtract 2400001.0 to shift from noon to midnight epoch
      return jd - 2400001.0;
    }

    // Initialize Stellarium
    function initStellarium() {
      const canvas = document.getElementById('stellarium-canvas');

      // Resize canvas
      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
      }

      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      // Create Stellarium engine
      StelWebEngine({
        canvas: canvas,
        wasmFile: 'stellarium-web-engine.wasm',
        onReady: function(stel) {
          window.stellarium = stel;
          window.stellariumReady = true;

          // Capture Module reference for touch forwarding
          // Module is created by Emscripten and has _core_on_mouse
          if (typeof Module !== 'undefined') {
            window.stelModule = Module;
          } else if (typeof window.Module !== 'undefined') {
            window.stelModule = window.Module;
          } else if (stel._module) {
            window.stelModule = stel._module;
          } else if (stel.Module) {
            window.stelModule = stel.Module;
          } else {
            // Search for _core_on_mouse in window properties
            for (var key in window) {
              if (window[key] && typeof window[key]._core_on_mouse === 'function') {
                window.stelModule = window[key];
                break;
              }
            }
          }

          const core = stel.core;
          // Remote base URL depends on the device language.
          // For Chinese locales, use the China-specific mirror.
          const language =
            (navigator.languages && navigator.languages.length ? navigator.languages[0] : navigator.language || '')
              .toLowerCase();
          const remoteBaseUrl = language.startsWith('zh')
            ? 'https://data.star-registration.com.cn/'
            : 'https://data.star-register.com/';
          // Always load star data from remote server (data.star-register.com)
          // to ensure we have the full catalog including dim stars

	          // Add data sources
	          core.stars.addDataSource({ url: remoteBaseUrl + 'surveys/stars/v1' });
	          core.stars.addDataSource({
	            url: remoteBaseUrl + 'surveys/gaia/v1',
	            key: 'gaia'
	          });
	          core.skycultures.addDataSource({
	            url: remoteBaseUrl + 'skycultures/v2/western',
	            key: 'western'
	          });
	          core.dsos.addDataSource({ url: remoteBaseUrl + 'surveys/dso/v1' });
	          core.milkyway.addDataSource({ url: remoteBaseUrl + 'surveys/milkyway/v1' });
	          core.dss.addDataSource({ url: remoteBaseUrl + 'surveys/dss/v1' });
	          core.minor_planets.addDataSource({
	            url: remoteBaseUrl + 'mpc/v1/mpcorb.dat',
	            key: 'mpc_asteroids'
	          });
	          core.comets.addDataSource({
	            url: remoteBaseUrl + 'mpc/v1/CometEls.txt?v=2019-12-17',
	            key: 'mpc_comets'
	          });
	          core.satellites.addDataSource({
	            url: remoteBaseUrl + 'skysources/v1/tle_satellite.jsonl.gz?v=2019-09-16',
	            key: 'jsonl/sat'
	          });
	          core.planets.addDataSource({
	            url: remoteBaseUrl + 'surveys/sso/moon/v1',
	            key: 'moon'
	          });
	          core.planets.addDataSource({
	            url: remoteBaseUrl + 'surveys/sso/sun/v1',
	            key: 'sun'
	          });
	          core.planets.addDataSource({
	            url: remoteBaseUrl + 'surveys/sso/callisto/v1',
	            key: 'callisto'
	          });
	          core.planets.addDataSource({
	            url: remoteBaseUrl + 'surveys/sso/default/v1',
	            key: 'default'
	          });
	          core.planets.addDataSource({
	            url: remoteBaseUrl + 'surveys/sso/europa/v1',
	            key: 'europa'
	          });
	          core.planets.addDataSource({
	            url: remoteBaseUrl + 'surveys/sso/ganymede/v1',
	            key: 'ganymede'
	          });
	          core.planets.addDataSource({
	            url: remoteBaseUrl + 'surveys/sso/io/v1',
	            key: 'io'
	          });
	          core.planets.addDataSource({
	            url: remoteBaseUrl + 'surveys/sso/jupiter/v1',
	            key: 'jupiter'
	          });
	          core.planets.addDataSource({
	            url: remoteBaseUrl + 'surveys/sso/mars/v1',
	            key: 'mars'
	          });
	          core.planets.addDataSource({
	            url: remoteBaseUrl + 'surveys/sso/mercury/v1',
	            key: 'mercury'
	          });
	          core.planets.addDataSource({
	            url: remoteBaseUrl + 'surveys/sso/moon-normal/v1',
	            key: 'moon-normal'
	          });
	          core.planets.addDataSource({
	            url: remoteBaseUrl + 'surveys/sso/neptune/v1',
	            key: 'neptune'
	          });
	          core.planets.addDataSource({
	            url: remoteBaseUrl + 'surveys/sso/saturn/v1',
	            key: 'saturn'
	          });
	          core.planets.addDataSource({
	            url: remoteBaseUrl + 'surveys/sso/uranus/v1',
	            key: 'uranus'
	          });
	          core.planets.addDataSource({
	            url: remoteBaseUrl + 'surveys/sso/venus/v1',
	            key: 'venus'
	          });
	          core.landscapes.addDataSource({
	            url: remoteBaseUrl + 'landscapes/v1/guereins',
	            key: 'guereins'
	          });

	          // Constellation art in the engine is quite subtle by default.
	          // Increase illustration brightness/opacity so the artwork is clearer.
	          if (core.constellations && core.constellations.illustrations_bscale != null) {
	            core.constellations.illustrations_bscale = 5.8;
	          }

	          // Default location (New York)
	          stel.observer.longitude = -74.0060 * stel.D2R;
	          stel.observer.latitude = 40.7128 * stel.D2R;

          // Set time to current time (now) and enable real-time progression
          var now = new Date();
          var mjd = dateToMjd(now);
          stel.observer.utc = mjd;
          // Set time speed to 1.0 for real-time progression
          if (stel.core) {
            stel.core.time_speed = 1.0;
          }
          console.log('Set initial time to now:', now.toISOString(), 'MJD:', mjd);

          // Set up time + fov change listener for explicit changes
          var lastUtc = stel.observer.utc;
          var lastFov = stel.observer.fov;
          stel.change(function(obj, attr) {
            // Check if observer UTC changed
            if (attr === 'utc' || (obj === stel.observer && stel.observer.utc !== lastUtc)) {
              lastUtc = stel.observer.utc;
              sendToFlutter('timeChanged', { utc: lastUtc });
            }

            // Check if FOV (zoom) changed
            if (attr === 'fov' || (obj === stel.observer && stel.observer.fov !== lastFov)) {
              const newFov = stel.observer.fov;
              if (Math.abs(newFov - lastFov) > 1e-4) { // ~0.006°
                lastFov = newFov;
                const fovDeg = lastFov * stel.R2D;
                console.log('fovChanged:', fovDeg.toFixed(2) + '°');
                sendToFlutter('fovChanged', { fov: fovDeg });
              }
            }
          });

          // Set up periodic time update for real-time progression
          // Check every second if time or fov has changed (due to real-time simulation)
          setInterval(function() {
            if (stel.observer.utc !== lastUtc) {
              lastUtc = stel.observer.utc;
              sendToFlutter('timeChanged', { utc: lastUtc });
            }
            if (Math.abs(stel.observer.fov - lastFov) > 1e-4) {
              lastFov = stel.observer.fov;
              const fovDeg = lastFov * stel.R2D;
              console.log('fovChanged(interval):', fovDeg.toFixed(2) + '°');
              sendToFlutter('fovChanged', { fov: fovDeg });
            }
          }, 1000);

          // Notify Flutter
          sendToFlutter('ready', {});
          // Send initial FOV so Flutter can scale gyro sensitivity
          try {
            const fovDeg = stel.observer.fov * stel.R2D;
            console.log('fovChanged(initial):', fovDeg.toFixed(2) + '°');
            sendToFlutter('fovChanged', { fov: fovDeg });
          } catch (e) {}

          console.log('Stellarium ready');
        }
      });
    }

    // API for Flutter to call
    window.stellariumAPI = {
      setLocation: function(lat, lon, alt) {
        if (!window.stellarium) return;
        const stel = window.stellarium;
        stel.observer.latitude = lat * stel.D2R;
        stel.observer.longitude = lon * stel.D2R;
        if (alt !== undefined) stel.observer.elevation = alt;
      },

      setTime: function(mjd) {
        if (!window.stellarium) return;
        window.stellarium.observer.utc = mjd;
      },

      setTimeSpeed: function(speed) {
        if (!window.stellarium || !window.stellarium.core) return;
        window.stellarium.core.time_speed = speed;
        console.log('Time speed set to:', speed);
      },

      getTimeSpeed: function() {
        if (!window.stellarium || !window.stellarium.core) return 1.0;
        return window.stellarium.core.time_speed || 1.0;
      },

      setFov: function(fovDeg, duration) {
        if (!window.stellarium) return;
        const fovRad = fovDeg * window.stellarium.D2R;
        window.stellarium.zoomTo(fovRad, duration || 1.0);
      },

      setSetting: function(key, value) {
        if (!window.stellarium) return;
        const core = window.stellarium.core;

        try {
          switch(key) {
            case 'constellationsLines':
              core.constellations.lines_visible = value;
              break;
            case 'constellationsLabels':
              core.constellations.labels_visible = value;
              break;
            case 'constellationsArt':
              core.constellations.images_visible = value;
              break;
            case 'atmosphere':
              core.atmosphere.visible = value;
              break;
            case 'landscape':
              core.landscapes.visible = value;
              break;
            case 'landscapeFog':
              core.landscapes.fog_visible = value;
              break;
            case 'milkyWay':
              core.milkyway.visible = value;
              break;
            case 'dss':
              core.dss.visible = value;
              break;
            case 'stars':
              core.stars.visible = value;
              break;
            case 'planets':
              core.planets.visible = value;
              break;
            case 'dsos':
              core.dsos.visible = value;
              break;
            case 'satellites':
              if (core.satellites) core.satellites.visible = value;
              break;
            case 'gridAzimuthal':
              core.lines.azimuthal.visible = value;
              break;
            case 'gridEquatorial':
              core.lines.equatorial_jnow.visible = value;
              break;
            case 'gridEquatorialJ2000':
              core.lines.equatorial.visible = value;
              break;
            case 'lineMeridian':
              core.lines.meridian.visible = value;
              break;
            case 'lineEcliptic':
              core.lines.ecliptic.visible = value;
              break;
          }
        } catch(e) {
          console.error('setSetting error:', key, e);
        }
      },

      getObserver: function() {
        if (!window.stellarium) return null;
        const stel = window.stellarium;
        const obs = stel.observer;
        return {
          latitude: obs.latitude * stel.R2D,
          longitude: obs.longitude * stel.R2D,
          altitude: obs.elevation,
          azimuth: obs.azimuth * stel.R2D,
          elevation: obs.altitude * stel.R2D,
          fov: obs.fov * stel.R2D,
          utc: obs.utc
        };
      },

      // Helper to normalize a name for comparison (remove spaces, uppercase)
      normalizeName: function(name) {
        return name.toUpperCase().replace(/\s+/g, '');
      },

      // Check if a query looks like a registration number (e.g., "9736-58577-3012084")
      isRegistrationNumber: function(query) {
        // Registration numbers have format: XXXX-XXXXX-XXXXXXX (digits with dashes)
        return /^\d{4}-\d{5}-\d{7}$/.test(query);
      },

      // Get the appropriate API URL for a query
      getApiUrl: function(query) {
        if (this.isRegistrationNumber(query)) {
          // Registration number endpoint
          return 'https://registry-api.celestial-register.com/?RN=' + encodeURIComponent(query);
        } else {
          // Name search endpoint
          return 'https://registry-api.celestial-register.com/search?name=' + encodeURIComponent(query);
        }
      },

      // Parse API response - different endpoints return different formats
      parseApiResponse: function(query, response) {
        if (this.isRegistrationNumber(query)) {
          // RN endpoint returns a single object with { found: true, model, model_data, ... }
          if (response && response.found && response.model_data) {
            return response;  // Return the object directly as a sky source
          }
          return null;
        } else {
          // search endpoint returns an array of results
          if (response && response.length > 0) {
            return response[0];
          }
          return null;
        }
      },

      // Validate that API result matches the search query (prevent fuzzy match errors)
      validateApiResult: function(searchQuery, skySource) {
        if (!skySource) return false;

        // For registration number queries, validate differently
        if (this.isRegistrationNumber(searchQuery)) {
          // RN endpoint returns { found: true, info: { registration_number: "..." } }
          if (skySource.found && skySource.info && skySource.info.registration_number) {
            const matches = skySource.info.registration_number === searchQuery;
            console.log('[validateApiResult] Registration number match:', matches);
            return matches;
          }
          // Also accept if found is true and we have model_data
          if (skySource.found && skySource.model_data) {
            console.log('[validateApiResult] Registration number found with model_data');
            return true;
          }
          return false;
        }

        // For name searches, require names array
        if (!skySource.names) return false;

        const normalizedQuery = this.normalizeName(searchQuery);

        // Check if any of the returned names exactly match the query
        for (const name of skySource.names) {
          const normalizedName = this.normalizeName(name);
          if (normalizedName === normalizedQuery) {
            console.log('[validateApiResult] Exact match found:', name);
            return true;
          }
        }

        // Check short_name
        if (skySource.short_name) {
          const normalizedShortName = this.normalizeName(skySource.short_name);
          if (normalizedShortName === normalizedQuery) {
            console.log('[validateApiResult] Short name match:', skySource.short_name);
            return true;
          }
        }

        // Check match field
        if (skySource.match) {
          const normalizedMatch = this.normalizeName(skySource.match);
          if (normalizedMatch === normalizedQuery) {
            console.log('[validateApiResult] Match field match:', skySource.match);
            return true;
          }
        }

        console.log('[validateApiResult] REJECTED - No exact match for query:', searchQuery, 'in names:', skySource.names);
        return false;
      },

      // Convert API sky source response to SweObj (mirrors sw_helpers.js skySource2SweObj)
      skySource2SweObj: function(ss) {
        if (!ss || !ss.model) {
          console.log('[skySource2SweObj] No model in sky source');
          return undefined;
        }
        if (!window.stellarium) {
          console.log('[skySource2SweObj] Stellarium not ready');
          return undefined;
        }
        const stel = window.stellarium;
        let obj = null;

        // Helper to normalize catalog designations (add space after catalog prefix)
        // Engine stores "HIP 90156" but API may return "HIP90156"
        const normalizeDesignation = (name) => {
          // Match catalog prefixes followed immediately by digits
          const match = name.match(/^(HIP|HD|HR|SAO|TYC|NGC|IC|M|Gaia DR2|GAIA)(\d+.*)$/i);
          if (match) {
            return match[1].toUpperCase() + ' ' + match[2];
          }
          return name;
        };

        // Helper to try a name with various formats
        const tryName = (name) => {
          console.log('[tryName] Input name:', name);

          // PRIORITY: Direct HIP lookup by number - fastest and most reliable
          // Registry API always returns HIP information, so try this first
          const hipMatch = name.match(/^HIP\s*(\d+)/i);
          console.log('[tryName] HIP match result:', hipMatch);
          if (hipMatch && typeof stel.getObjByHip === 'function') {
            const hipNumber = parseInt(hipMatch[1], 10);
            console.log('[tryName] Trying direct HIP lookup for:', hipNumber);
            const result = stel.getObjByHip(hipNumber);
            console.log('[tryName] HIP lookup result:', result);
            if (result) {
              console.log('[tryName] FOUND via HIP lookup:', hipNumber);
              if (typeof result.designations === 'function') {
                console.log('[tryName] Found object designations:', result.designations());
              }
              return result;
            } else {
              console.log('[tryName] HIP lookup returned null for:', hipNumber);
            }
          } else if (hipMatch) {
            console.log('[tryName] getObjByHip not available');
          }

          // Fallback: string-based search with various name formats
          const attempts = [];

          // Direct name
          attempts.push(name);

          // With "NAME " prefix
          attempts.push('NAME ' + name);

          // With "* " prefix (Bayer/Flamsteed star designations)
          attempts.push('* ' + name);

          // Normalized version (add space after catalog prefix like HIP, HD)
          const normalized = normalizeDesignation(name);
          if (normalized !== name) {
            attempts.push(normalized);
          }

          // Try with "* " prefix on normalized too
          if (normalized !== name) {
            attempts.push('* ' + normalized);
          }

          // If name has a component suffix like "A" or "B", try without it
          const withoutComponent = name.replace(/\s*[A-Z]$/, '');
          if (withoutComponent !== name) {
            attempts.push(withoutComponent);
            attempts.push('* ' + withoutComponent);
          }

          for (const attempt of attempts) {
            console.log('[skySource2SweObj] Trying:', attempt);
            const result = stel.getObj(attempt);
            if (result) {
              console.log('[skySource2SweObj] FOUND with:', attempt);
              if (typeof result.designations === 'function') {
                console.log('[skySource2SweObj] Found object designations:', result.designations());
              }
              return result;
            }
          }

          return null;
        };

        // Handle TLE satellites specially
        if (ss.model === 'tle_satellite' && ss.model_data && ss.model_data.norad_number) {
          const id = 'NORAD ' + ss.model_data.norad_number;
          console.log('[skySource2SweObj] TLE satellite, trying:', id);
          obj = stel.getObj(id);
        }
        // Handle constellations specially
        else if (ss.model === 'constellation' && ss.model_data && ss.model_data.iau_abbreviation) {
          const id = 'CON western ' + ss.model_data.iau_abbreviation;
          console.log('[skySource2SweObj] Constellation, trying:', id);
          obj = stel.getObj(id);
        }

        // Default: try names from the API response
        if (!obj && ss.names && ss.names.length > 0) {
          for (let i = 0; i < ss.names.length; i++) {
            obj = tryName(ss.names[i]);
            if (obj) break;

            // Gaia DR2 fallback - transform name format
            if (ss.names[i].startsWith('Gaia DR2 ')) {
              const gname = ss.names[i].replace(/^Gaia DR2 /, 'GAIA ');
              console.log('[skySource2SweObj] Gaia fallback, trying:', gname);
              obj = stel.getObj(gname);
              if (obj) break;
            }
          }
        }

        // Last resort: CREATE the object from coordinates using createObj()
        // This is the key insight from engineHelper.js - you don't search, you CREATE
        if (!obj && ss.model_data && ss.model_data.ra !== undefined && ss.model_data.de !== undefined) {
          console.log('[skySource2SweObj] Object not found locally, creating from coordinates...');
          console.log('[skySource2SweObj] model:', ss.model);
          console.log('[skySource2SweObj] model_data:', JSON.stringify(ss.model_data));
          console.log('[skySource2SweObj] RA:', ss.model_data.ra, 'DE:', ss.model_data.de);
          console.log('[skySource2SweObj] stel.createObj exists:', typeof stel.createObj);
          try {
            // createObj takes (model, objectData) and returns a SweObj pointer
            obj = stel.createObj(ss.model, ss);
            console.log('[skySource2SweObj] createObj returned:', obj);
            if (obj) {
              console.log('[skySource2SweObj] SUCCESS - Created object from coordinates');
              console.log('[skySource2SweObj] Object type:', typeof obj, 'value:', obj);
            } else {
              console.log('[skySource2SweObj] createObj returned null/undefined');
            }
          } catch (createErr) {
            console.error('[skySource2SweObj] createObj failed:', createErr);
            console.error('[skySource2SweObj] Error stack:', createErr.stack);
          }
        } else if (!obj) {
          console.log('[skySource2SweObj] Cannot create - missing data:');
          console.log('[skySource2SweObj]   ss.model_data:', ss.model_data);
          console.log('[skySource2SweObj]   ra:', ss.model_data?.ra);
          console.log('[skySource2SweObj]   de:', ss.model_data?.de);
        }

        if (obj) {
          console.log('[skySource2SweObj] SUCCESS - Found/created object');
        } else {
          console.log('[skySource2SweObj] FAILED - Object not found and could not be created');
        }
        return obj;
      },

      // Unified object finder - searches API first, then falls back to local engine
      // Returns { obj, skySource, displayName } or null
      findObject: async function(query) {
        console.log('[FIND] Looking for:', query);
        if (!window.stellarium) return null;

        const stel = window.stellarium;
        const isRegNum = this.isRegistrationNumber(query);

        // 1. Try API search first
        try {
          const apiUrl = this.getApiUrl(query);
          const response = await fetch(apiUrl);
          if (response.ok) {
            const rawResponse = await response.json();
            const skySource = this.parseApiResponse(query, rawResponse);
            if (skySource && this.validateApiResult(query, skySource)) {
              const obj = this.skySource2SweObj(skySource);
              if (obj) {
                // Determine display name
                let displayName = query;
                if (isRegNum && skySource.info && skySource.info.name) {
                  displayName = skySource.info.name;
                } else if (skySource.names && skySource.names.length > 0) {
                  displayName = skySource.names[0];
                }
                console.log('[FIND] Found via API:', displayName);
                return { obj, skySource, displayName };
              }
            }
          }
        } catch (e) {
          console.error('[FIND] API error:', e);
        }

        // 2. Fall back to local engine
        let obj = stel.getObj('NAME ' + query) || stel.getObj(query);
        if (obj) {
          console.log('[FIND] Found locally:', query);
          return { obj, skySource: null, displayName: query };
        }

        console.log('[FIND] Not found:', query);
        return null;
      },

      // Build object info for Flutter from found object
      buildObjectInfo: function(obj, displayName, skySource) {
        const stel = window.stellarium;
        let names = typeof obj.designations === 'function' ? obj.designations() : (obj.names || []);

        // Fall back to skySource names if needed
        if ((!names || names.length === 0) && skySource) {
          if (skySource.names && skySource.names.length > 0) {
            names = skySource.names;
          } else if (skySource.model_data) {
            const md = skySource.model_data;
            names = [];
            if (md.short_name) names.push(md.short_name);
            if (md.identifier) names.push(md.identifier);
          }
        }

        return {
          name: displayName,
          names: names.length > 0 ? names : [displayName],
          type: obj.type || 'unknown',
          vmag: obj.vmag,
          ra: obj.ra !== undefined ? obj.ra * stel.R2D : null,
          dec: obj.de !== undefined ? obj.de * stel.R2D : null,
          distance: obj.distance,
          skySource: skySource
        };
      },

      search: async function(query) {
        const result = await this.findObject(query);
        if (!result) return null;
        return { name: result.displayName, type: result.obj.type || 'unknown', skySource: result.skySource };
      },

      pointAt: async function(name, duration) {
        if (!window.stellarium) return;
        const result = await this.findObject(name);
        if (!result) return;

        const stel = window.stellarium;
        const { obj, skySource, displayName } = result;

        // Log current zoom level
        const currentFov = stel.observer.fov * 180 / Math.PI;
        console.log('[pointAt] Current FOV:', currentFov.toFixed(2) + '°');

        // Clear any existing lock first to ensure clean transition
        stel.core.lock = null;
        stel.observer.view_offset_alt = 0;

        // Target FOV for viewing stars
        const targetFov = 20 * Math.PI / 180;  // 20 degrees
        console.log('[pointAt] Target FOV:', (targetFov * 180 / Math.PI).toFixed(2) + '°');

        // Step 1: Zoom out first
        const zoomDuration = 0.5;
        stel.zoomTo(targetFov, zoomDuration);

        // Step 2: After zoom completes, move to the star
        setTimeout(() => {
          stel.core.selection = obj;
          stel.observer.view_offset_alt = targetFov * 0.35;
          stel.pointAndLock(obj, duration || 1.0);
        }, zoomDuration * 1000);

        // Notify Flutter
        const info = this.buildObjectInfo(obj, displayName, skySource);
        sendToFlutter('objectSelected', info);
      },

      // Select an object without moving the camera (for gyroscope mode)
      selectObject: async function(name) {
        if (!window.stellarium) return;
        const result = await this.findObject(name);
        if (!result) return;

        const stel = window.stellarium;
        const { obj, skySource, displayName } = result;

        stel.core.selection = obj;
        const info = this.buildObjectInfo(obj, displayName, skySource);
        sendToFlutter('objectSelected', info);
      },

      lookAt: function(azimuthDeg, altitudeDeg, duration) {
        if (!window.stellarium) return;
        try {
          const stel = window.stellarium;
          const azRad = azimuthDeg * stel.D2R;
          const altRad = altitudeDeg * stel.D2R;
          // Convert spherical to cartesian direction vector
          var pos = stel.s2c(azRad, altRad);
          stel.lookAt(pos, duration || 0);
        } catch(e) {
          console.error('lookAt error:', e);
        }
      },

      lookAtRadians: function(azimuthRad, altitudeRad, duration) {
        if (!window.stellarium) {
          console.log('lookAtRadians: stellarium not ready');
          return;
        }
        try {
          const stel = window.stellarium;
          // Convert spherical (azimuth, altitude) to cartesian direction vector
          var pos = stel.s2c(azimuthRad, altitudeRad);
          stel.lookAt(pos, duration || 0);
        } catch(e) {
          console.error('lookAtRadians error:', e);
        }
      },

      setGyroscopeEnabled: function(enabled) {
        window.gyroscopeEnabled = enabled;
        // Set the engine's gyroscope_mode property for native arrow rendering
        if (window.stellarium && window.stellarium.core) {
          window.stellarium.core.gyroscope_mode = enabled;
        }
        console.log('Gyroscope mode:', enabled ? 'enabled' : 'disabled');
      },

      setTouchEnabled: function(enabled) {
        window.touchEnabled = enabled;
        console.log('Touch handling:', enabled ? 'enabled' : 'disabled');
      },

      // Touch events forwarded from Flutter (bypasses native WebView touch handling)
      // Track active touches for multi-finger gesture detection
      _activeTouches: new Set(),

      onTouchStart: function(id, x, y) {
        this._activeTouches.add(id);
        if (window.stelModule && window.stelModule._core_on_mouse) {
          window.stelModule._core_on_mouse(id, 1, x, y, 1);
          // Track for tap detection
          window._touchStartX = x;
          window._touchStartY = y;
          window._touchStartTime = Date.now();
          window._touchId = id;
        }
      },

      onTouchMove: function(id, x, y) {
        // Allow moves if gyroscope disabled OR if 2+ fingers (pinch-to-zoom)
        const allowMove = !window.gyroscopeEnabled || this._activeTouches.size >= 2;
        if (allowMove && window.stelModule && window.stelModule._core_on_mouse) {
          window.stelModule._core_on_mouse(id, -1, x, y, 1);
        }
      },

      onTouchEnd: function(id, x, y) {
        this._activeTouches.delete(id);
        if (window.stelModule && window.stelModule._core_on_mouse) {
          // Always send touch end - MUST use buttons=1 for engine to process (movements.c checks buttons==1)
          window.stelModule._core_on_mouse(id, 0, x, y, 1);

          // Check if this was a tap
          const dx = Math.abs(x - (window._touchStartX || 0));
          const dy = Math.abs(y - (window._touchStartY || 0));
          const duration = Date.now() - (window._touchStartTime || 0);
          const TAP_THRESHOLD = 15;
          const TAP_MAX_DURATION = 300;

          if (dx < TAP_THRESHOLD && dy < TAP_THRESHOLD && duration < TAP_MAX_DURATION) {
            console.log('Flutter-forwarded tap detected at:', x, y);
            if (window.gyroscopeEnabled) {
              const info = stellariumAPI.selectForGuidance(x, y);
              if (info && info.name) {
                sendToFlutter('objectSelected', info);
              }
            } else {
              // Normal tap - wait for engine to process
              requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                  const info = stellariumAPI.getSelectedObjectInfo();
                  if (info && info.name && info.name !== 'Unknown') {
                    sendToFlutter('objectSelected', info);
                  }
                });
              });
            }
          }
        }
      },

      // Get info about selected object
      getSelectedObjectInfo: function() {
        if (!window.stellarium) return null;
        try {
          const stel = window.stellarium;
          const selection = stel.core.selection;
          console.log('[getSelectedObjectInfo] selection:', selection);
          if (!selection) return null;

          // Use designations() method (not property) to get names
          const names = typeof selection.designations === 'function' ? selection.designations() : (selection.names || []);
          console.log('[getSelectedObjectInfo] designations():', names);
          console.log('[getSelectedObjectInfo] selection.type:', selection.type);
          console.log('[getSelectedObjectInfo] selection.ra:', selection.ra, 'de:', selection.de);
          console.log('[getSelectedObjectInfo] selection.vmag:', selection.vmag);

          // Get JSON data which includes HIP number for stars
          // Note: jsonData is a property getter, not a method
          let hip = null;
          let gaia = null;
          let jsonData = null;
          console.log('[getSelectedObjectInfo] checking jsonData property...');
          console.log('[getSelectedObjectInfo] selection keys:', Object.keys(selection));
          console.log('[getSelectedObjectInfo] has jsonData:', 'jsonData' in selection);
          try {
            jsonData = selection.jsonData;  // Property, not method
            console.log('[getSelectedObjectInfo] jsonData raw:', jsonData);
            console.log('[getSelectedObjectInfo] jsonData stringified:', JSON.stringify(jsonData));
            if (jsonData && jsonData.model_data) {
              console.log('[getSelectedObjectInfo] model_data:', JSON.stringify(jsonData.model_data));
              hip = jsonData.model_data.hip || null;
              gaia = jsonData.model_data.gaia || null;
              console.log('[getSelectedObjectInfo] HIP:', hip, 'GAIA:', gaia);
            } else {
              console.log('[getSelectedObjectInfo] jsonData or model_data is missing');
            }
          } catch (jsonErr) {
            console.error('[getSelectedObjectInfo] jsonData error:', jsonErr);
            console.error('[getSelectedObjectInfo] error stack:', jsonErr.stack);
          }

          // Debug: try to get more info about the object
          if (typeof selection.getInfo === 'function') {
            const obs = stel.core.observer;
            console.log('[getSelectedObjectInfo] getInfo("name"):', selection.getInfo('name', obs));
            console.log('[getSelectedObjectInfo] getInfo("short_name"):', selection.getInfo('short_name', obs));
            console.log('[getSelectedObjectInfo] getInfo("designations"):', selection.getInfo('designations', obs));
          }

          const info = {
            name: (names && names.length > 0) ? names[0] : 'Unknown',
            names: names || [],
            type: selection.type || 'unknown',
            vmag: selection.vmag,
            ra: selection.ra * stel.R2D,
            dec: selection.de * stel.R2D,
            distance: selection.distance,
            hip: hip,
            gaia: gaia
          };
          console.log('[getSelectedObjectInfo] returning:', info);
          return info;
        } catch(e) {
          console.error('getSelectedObjectInfo error:', e);
          return null;
        }
      },

      // Set a custom label for the currently selected star
      // This uses the native engine API to render the label in the sky view
      setCustomLabel: function(label) {
        if (!window.stellarium) {
          console.log('setCustomLabel: stellarium not ready');
          return;
        }

        const stel = window.stellarium;

        if (label && label.trim()) {
          // Use the native engine API to set the custom label
          stel.setSelectionCustomLabel(label);
          window.currentCustomLabel = label;
          console.log('Custom label set (native):', label);
        } else {
          this.clearCustomLabel();
        }
      },

      // Clear the custom label
      clearCustomLabel: function() {
        if (window.stellarium) {
          window.stellarium.setSelectionCustomLabel('');
        }
        window.currentCustomLabel = null;
        console.log('Custom label cleared');
      },

      // Add a persistent label for a star (shown without selection)
      addPersistentLabel: function(identifier, label) {
        if (!window.stellarium) {
          console.log('addPersistentLabel: stellarium not ready');
          return;
        }
        window.stellarium.addPersistentLabel(identifier, label);
        console.log('Persistent label added:', identifier, '->', label);
      },

      // Remove a persistent label for a star
      removePersistentLabel: function(identifier) {
        if (!window.stellarium) {
          console.log('removePersistentLabel: stellarium not ready');
          return;
        }
        window.stellarium.removePersistentLabel(identifier);
        console.log('Persistent label removed:', identifier);
      },

      // Clear all persistent labels
      clearPersistentLabels: function() {
        if (!window.stellarium) {
          console.log('clearPersistentLabels: stellarium not ready');
          return;
        }
        window.stellarium.clearPersistentLabels();
        console.log('All persistent labels cleared');
      },

      // Select object at screen coordinates
      selectAtPosition: function(x, y) {
        if (!window.stellarium) return null;
        try {
          const stel = window.stellarium;

          // Send click event to engine to trigger object selection
          // This mimics a mouse click at the position
          if (window.stelModule && window.stelModule._core_on_mouse) {
            // Mouse down (action=1) then up (action=0) = click
            // MUST use buttons=1 for both events (movements.c checks buttons==1)
            window.stelModule._core_on_mouse(99, 1, x, y, 1); // Use ID 99 for selection clicks
            window.stelModule._core_on_mouse(99, 0, x, y, 1);
          }

          // Read the selection that was set by the click
          const selection = stel.core.selection;
          console.log('selectAtPosition: selection =', selection, 'at', x, y);
          if (!selection) return null;

          // Use designations() method (not property) to get names
          const names = typeof selection.designations === 'function' ? selection.designations() : (selection.names || []);
          const info = {
            name: (names && names.length > 0) ? names[0] : 'Unknown',
            names: names || [],
            type: selection.type || 'unknown',
            vmag: selection.vmag,
            ra: selection.ra !== undefined ? selection.ra * stel.R2D : null,
            dec: selection.de !== undefined ? selection.de * stel.R2D : null,
            distance: selection.distance
          };
          console.log('selectAtPosition: returning info:', info);
          return info;
        } catch(e) {
          console.error('selectAtPosition error:', e);
          return null;
        }
      },

      // Select object at screen coordinates (async version - waits for engine to process)
      selectAtPositionAsync: function(x, y) {
        return new Promise((resolve) => {
          if (!window.stellarium) {
            resolve(null);
            return;
          }
          try {
            const stel = window.stellarium;

            // Send click event to engine to trigger object selection
            // MUST use buttons=1 for both events (movements.c checks buttons==1)
            if (window.stelModule && window.stelModule._core_on_mouse) {
              window.stelModule._core_on_mouse(99, 1, x, y, 1);
              window.stelModule._core_on_mouse(99, 0, x, y, 1);
            }

            // Wait for next frame for engine to process the click
            requestAnimationFrame(() => {
              const selection = stel.core.selection;
              console.log('selectAtPositionAsync: selection =', selection);
              if (!selection) {
                resolve(null);
                return;
              }

              // Use designations() method (not property) to get names
              const names = typeof selection.designations === 'function' ? selection.designations() : (selection.names || []);
              const info = {
                name: (names && names.length > 0) ? names[0] : 'Unknown',
                names: names || [],
                type: selection.type || 'unknown',
                vmag: selection.vmag,
                ra: selection.ra !== undefined ? selection.ra * stel.R2D : null,
                dec: selection.de !== undefined ? selection.de * stel.R2D : null,
                distance: selection.distance
              };
              resolve(info);
            });
          } catch(e) {
            console.error('selectAtPositionAsync error:', e);
            resolve(null);
          }
        });
      },

      // Start gyroscope guidance to a star by name (also notifies Flutter)
      startGuidance: async function(name) {
        if (!window.stellarium) return false;
        const result = await this.findObject(name);
        if (!result) return false;

        const stel = window.stellarium;
        const { obj, skySource, displayName } = result;
        stel.core.selection = obj;
        startGyroscopeGuidance(obj, displayName);

        // Notify Flutter about the selected object
        const info = this.buildObjectInfo(obj, displayName, skySource);
        sendToFlutter('objectSelected', info);
        return true;
      },

      // Stop gyroscope guidance
      stopGuidance: function() {
        stopGyroscopeGuidance();
        // Clear selection as well
        if (window.stellarium) {
          window.stellarium.core.selection = null;
        }
      },

      // Set star tracking (24-hour path) visibility
      setStarTrackVisible: function(visible) {
        if (!window.stellarium || !window.stellarium.core) {
          console.log('setStarTrackVisible: stellarium not ready');
          return false;
        }
        try {
          const core = window.stellarium.core;
          // Access the star_track module
          if (core.star_track) {
            core.star_track.visible = visible;
            console.log('Star track visibility set to:', visible);
            return true;
          } else {
            console.log('setStarTrackVisible: star_track module not found in core');
            // List available modules for debugging
            console.log('Available core properties:', Object.keys(core));
            return false;
          }
        } catch(e) {
          console.error('setStarTrackVisible error:', e);
          return false;
        }
      },

      // Select object at position in gyroscope mode (no view change)
      selectForGuidance: function(x, y) {
        if (!window.stellarium) return null;
        try {
          const stel = window.stellarium;

          // Send click event to engine to trigger object selection
          // MUST use buttons=1 for both events (movements.c checks buttons==1)
          if (window.stelModule && window.stelModule._core_on_mouse) {
            window.stelModule._core_on_mouse(99, 1, x, y, 1);
            window.stelModule._core_on_mouse(99, 0, x, y, 1);
          }

          // Read the selection
          const selection = stel.core.selection;
          if (!selection) return null;

          // Use designations() method (not property) to get names
          const names = typeof selection.designations === 'function' ? selection.designations() : (selection.names || []);
          const name = (names && names.length > 0) ? names[0] : 'Unknown';

          // Start guidance to selected object
          startGyroscopeGuidance(selection, name);

          const info = {
            name: name,
            names: names || [],
            type: selection.type || 'unknown',
            vmag: selection.vmag,
            ra: selection.ra !== undefined ? selection.ra * stel.R2D : null,
            dec: selection.de !== undefined ? selection.de * stel.R2D : null,
            distance: selection.distance
          };
          return info;
        } catch(e) {
          console.error('selectForGuidance error:', e);
          return null;
        }
      }
    };

    // Gyroscope mode flag - when true, disable touch panning
    window.gyroscopeEnabled = false;

    // Touch enabled flag - when false, ignore ALL touch events
    window.touchEnabled = true;

    // Direction arrow is now rendered natively in the engine (pointer.c)
    // when gyroscope_mode is enabled and selection is off-screen.
    // These functions are kept for API compatibility but do minimal work.

    // Start tracking a target for gyroscope guidance (now handled by engine)
    function startGyroscopeGuidance(obj, name) {
      console.log('Gyroscope guidance started for:', name);
      // Arrow is now rendered by the engine's pointer module
    }

    // Stop gyroscope guidance (now handled by engine)
    function stopGyroscopeGuidance() {
      console.log('Gyroscope guidance stopped');
      // Arrow is now rendered by the engine's pointer module
    }

    // NOTE: Native touch handling is now done in canvas.js (stellarium-web-engine)
    // with UI bounds filtering. These document-level handlers are disabled to
    // prevent double-processing of touch events.
    // The canvas.js handlers check window.uiBounds before processing any touch.

    // Start
    if (typeof StelWebEngine !== 'undefined') {
      initStellarium();
    } else {
      window.addEventListener('load', function() {
        if (typeof StelWebEngine !== 'undefined') {
          initStellarium();
        } else {
          sendToFlutter('error', { message: 'StelWebEngine not loaded' });
        }
      });
    }
  </script>
</body>
</html>
