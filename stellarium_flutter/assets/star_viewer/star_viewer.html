<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>3D Star Viewer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    #canvas-container {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
    }
    canvas {
      display: block;
    }
    #close-button {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      padding: 14px 48px;
      border-radius: 30px;
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      font-size: 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      cursor: pointer;
      z-index: 100;
      transition: all 0.2s;
      -webkit-tap-highlight-color: transparent;
    }
    #close-button:hover, #close-button:active {
      background: rgba(255, 255, 255, 0.25);
      transform: translateX(-50%) scale(1.02);
    }
    #close-button svg {
      width: 20px;
      height: 20px;
    }
    #star-name {
      position: absolute;
      bottom: 130px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 24px;
      font-weight: 600;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      z-index: 100;
      text-align: center;
      max-width: 80%;
    }
    #spectral-type {
      position: absolute;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.7);
      font-size: 14px;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      z-index: 100;
    }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 16px;
      z-index: 100;
    }
    .loader {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-top: 3px solid #FFD700;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 12px;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <div id="loading">
    <div class="loader"></div>
    <div>Loading 3D Star...</div>
  </div>
  <button id="close-button" onclick="closeViewer()">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <line x1="19" y1="12" x2="5" y2="12"></line>
      <polyline points="12 19 5 12 12 5"></polyline>
    </svg>
    <span id="back-text">Back</span>
  </button>
  <div id="star-name"></div>
  <div id="spectral-type"></div>

  <!-- Three.js and required modules -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // Parse URL parameters
    const params = new URLSearchParams(window.location.search);
    const starName = params.get('name') || 'Star';
    const spectralType = params.get('spectralType') || 'G2V';
    const customCoreColor = params.get('coreColor');
    const customSurfaceColor = params.get('surfaceColor');
    const backText = params.get('backText') || 'Back';

    // Display star name and back button text
    document.getElementById('star-name').textContent = starName;
    document.getElementById('spectral-type').textContent = 'Spectral Type: ' + spectralType;
    document.getElementById('back-text').textContent = backText;

    // Spectral type to color mapping (matching your SunConfig)
    function getStarColors(spectral) {
      const type = (spectral || 'G').charAt(0).toUpperCase();
      const colors = {
        'O': { core: '#9bb0ff', surface: '#aac0ff' },
        'B': { core: '#aabfff', surface: '#bbccff' },
        'A': { core: '#cad7ff', surface: '#dde5ff' },
        'F': { core: '#f8f7ff', surface: '#fffef8' },
        'G': { core: '#fff4ea', surface: '#ffcc66' },  // Sun-like
        'K': { core: '#ffd2a1', surface: '#ff9933' },
        'M': { core: '#ffcc6f', surface: '#ff6633' },
        'L': { core: '#ff6633', surface: '#cc3300' },
        'T': { core: '#cc3300', surface: '#990000' },
      };
      return colors[type] || colors['G'];
    }

    const starColors = getStarColors(spectralType);

    // Config object matching your SunConfig interface
    const config = {
      coreColor: customCoreColor || starColors.core,
      surfaceColor: customSurfaceColor || starColors.surface,
      turbulence: 1.5,
      pulseSpeed: 0.3,
      rotationSpeed: 0.1,
      bloomIntensity: 1.2,
      rayIntensity: 0.25
    };

    // ============ SHADERS (exact from your code) ============

    const sunVertexShader = `
uniform float uTime;
uniform float uPulseSpeed;
varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vPosition;

// Helper functions for Noise
vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
vec4 permute(vec4 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

// Simplex 3D Noise
float snoise(vec3 v){
  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

  vec3 i  = floor(v + dot(v, C.yyy) );
  vec3 x0 = v - i + dot(i, C.xxx) ;

  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min( g.xyz, l.zxy );
  vec3 i2 = max( g.xyz, l.zxy );

  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
  vec3 x3 = x0 - 1.0 + 3.0 * C.xxx;

  i = mod(i, 289.0 );
  vec4 p = permute( permute( permute(
             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

  float n_ = 1.0/7.0;
  vec3  ns = n_ * D.wyz - D.xzx;

  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);

  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_ );

  vec4 x = x_ *ns.x + ns.yyyy;
  vec4 y = y_ *ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);

  vec4 b0 = vec4( x.xy, y.xy );
  vec4 b1 = vec4( x.zw, y.zw );

  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));

  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

  vec3 p0 = vec3(a0.xy,h.x);
  vec3 p1 = vec3(a0.zw,h.y);
  vec3 p2 = vec3(a1.xy,h.z);
  vec3 p3 = vec3(a1.zw,h.w);

  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                dot(p2,x2), dot(p3,x3) ) );
}

void main() {
  vUv = uv;
  vNormal = normal;
  vPosition = position;

  // Dynamic Pulse Effect
  float noiseVal = snoise(vec3(position * 2.0 + uTime * uPulseSpeed));
  float displacement = noiseVal * 0.05;

  vec3 newPosition = position + normal * displacement;

  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
}
`;

    const sunFragmentShader = `
uniform float uTime;
uniform float uTurbulence;
uniform vec3 uCoreColor;
uniform vec3 uSurfaceColor;

varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vPosition;

// 3D Simplex Noise for plasma pattern
vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
vec4 permute(vec4 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

float snoise(vec3 v){
  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

  vec3 i  = floor(v + dot(v, C.yyy) );
  vec3 x0 = v - i + dot(i, C.xxx) ;

  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min( g.xyz, l.zxy );
  vec3 i2 = max( g.xyz, l.zxy );

  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
  vec3 x3 = x0 - 1.0 + 3.0 * C.xxx;

  i = mod(i, 289.0 );
  vec4 p = permute( permute( permute(
             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

  float n_ = 1.0/7.0;
  vec3  ns = n_ * D.wyz - D.xzx;

  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);

  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_ );

  vec4 x = x_ *ns.x + ns.yyyy;
  vec4 y = y_ *ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);

  vec4 b0 = vec4( x.xy, y.xy );
  vec4 b1 = vec4( x.zw, y.zw );

  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));

  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

  vec3 p0 = vec3(a0.xy,h.x);
  vec3 p1 = vec3(a0.zw,h.y);
  vec3 p2 = vec3(a1.xy,h.z);
  vec3 p3 = vec3(a1.zw,h.w);

  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                dot(p2,x2), dot(p3,x3) ) );
}

// Fractal Brownian Motion
float fbm(vec3 p) {
    float total = 0.0;
    float amplitude = 0.5;
    float frequency = 1.0;
    for(int i = 0; i < 4; i++) {
        total += snoise(p * frequency) * amplitude;
        frequency *= 2.0;
        amplitude *= 0.5;
    }
    return total;
}

void main() {
  // Moving noise coordinates
  vec3 coord = vPosition * uTurbulence + vec3(0.0, -uTime * 0.2, uTime * 0.1);
  float noiseVal = fbm(coord);

  // Remap noise from [-1, 1] to [0, 1]
  float n = (noiseVal + 1.0) * 0.5;

  // Fresnel effect for edge glowing
  vec3 viewDir = normalize(cameraPosition - vPosition);
  float fresnel = pow(1.0 - dot(viewDir, vNormal), 2.0);

  // Mix colors
  vec3 color = mix(uCoreColor, uSurfaceColor, n);

  // Add intense heat to bright spots
  float heat = smoothstep(0.4, 0.8, n);
  color += vec3(1.0, 1.0, 0.8) * heat * 1.5;

  // Edge glow
  color += uSurfaceColor * fresnel * 1.2;

  gl_FragColor = vec4(color, 1.0);
}
`;

    const raysVertexShader = `
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;

    const raysFragmentShader = `
uniform float uTime;
uniform vec3 uColor;
uniform float uIntensity;
varying vec2 vUv;

void main() {
  vec2 uv = vUv - 0.5;
  // Convert to polar coordinates
  float dist = length(uv) * 2.0;
  float angle = atan(uv.y, uv.x);

  // Create thin rays using high exponents on sine waves
  float r1 = sin(angle * 30.0 + uTime * 0.1);
  r1 = pow(max(0.0, r1), 40.0);

  float r2 = sin(angle * 47.0 - uTime * 0.15);
  r2 = pow(max(0.0, r2), 30.0);

  float rays = r1 + r2 * 0.6;

  // Radial attenuation (fade out at edges)
  float fade = 1.0 - smoothstep(0.0, 0.8, dist);
  fade = pow(fade, 2.0);

  // Combine
  float alpha = rays * fade * uIntensity;

  gl_FragColor = vec4(uColor, alpha);
}
`;

    // ============ Three.js Setup ============

    let scene, camera, renderer, controls, composer;
    let sun, sunRays;
    let clock = new THREE.Clock();
    let animationId;

    function init() {
      const container = document.getElementById('canvas-container');

      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      // Camera - positioned further back for better view
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 8);

      // Renderer with Reinhard tone mapping
      renderer = new THREE.WebGLRenderer({ antialias: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.toneMapping = THREE.ReinhardToneMapping;
      container.appendChild(renderer.domElement);

      // OrbitControls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enablePan = false;
      controls.minDistance = 4;
      controls.maxDistance = 15;
      controls.zoomSpeed = 0.5;
      controls.rotateSpeed = 0.5;
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Create objects
      createBackgroundStars();
      createSun();
      createSunRays();

      // Post-processing with Bloom
      setupPostProcessing();

      // Event listeners
      window.addEventListener('resize', onWindowResize, false);

      // Hide loading
      document.getElementById('loading').style.display = 'none';

      // Start animation
      animate();
    }

    function createBackgroundStars() {
      // Matching drei Stars: radius=300, depth=50, count=5000
      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      const sizes = [];

      for (let i = 0; i < 5000; i++) {
        // Distributed in a shell between radius 250-350
        const radius = 250 + Math.random() * 100;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);

        vertices.push(
          radius * Math.sin(phi) * Math.cos(theta),
          radius * Math.sin(phi) * Math.sin(theta),
          radius * Math.cos(phi)
        );

        // Varying sizes (factor=4 in drei)
        sizes.push(Math.random() * 4 + 0.5);
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

      // Custom shader for stars with size attenuation and fade
      const starMaterial = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 }
        },
        vertexShader: `
          attribute float size;
          varying float vSize;
          void main() {
            vSize = size;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = size * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          varying float vSize;
          void main() {
            float dist = length(gl_PointCoord - vec2(0.5));
            if (dist > 0.5) discard;
            float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
            gl_FragColor = vec4(1.0, 1.0, 1.0, alpha * 0.8);
          }
        `,
        transparent: true,
        depthWrite: false
      });

      const stars = new THREE.Points(geometry, starMaterial);
      scene.add(stars);
    }

    function createSun() {
      const geometry = new THREE.SphereGeometry(1.2, 64, 64);

      const material = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uTurbulence: { value: config.turbulence },
          uPulseSpeed: { value: config.pulseSpeed },
          uCoreColor: { value: new THREE.Color(config.coreColor) },
          uSurfaceColor: { value: new THREE.Color(config.surfaceColor) }
        },
        vertexShader: sunVertexShader,
        fragmentShader: sunFragmentShader,
        side: THREE.DoubleSide
      });

      sun = new THREE.Mesh(geometry, material);
      scene.add(sun);
    }

    function createSunRays() {
      // Billboard plane for sun rays
      const geometry = new THREE.PlaneGeometry(6, 6);

      const material = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uColor: { value: new THREE.Color(config.surfaceColor) },
          uIntensity: { value: config.rayIntensity }
        },
        vertexShader: raysVertexShader,
        fragmentShader: raysFragmentShader,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        side: THREE.DoubleSide
      });

      sunRays = new THREE.Mesh(geometry, material);
      scene.add(sunRays);
    }

    function setupPostProcessing() {
      composer = new EffectComposer(renderer);

      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);

      // Bloom pass (matching your React config)
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        config.bloomIntensity,  // intensity
        0.8,                     // radius
        0.2                      // threshold (luminanceThreshold)
      );
      composer.addPass(bloomPass);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      animationId = requestAnimationFrame(animate);

      const delta = clock.getDelta();
      const elapsed = clock.getElapsedTime();

      // Update controls
      controls.update();

      // Update sun uniforms
      if (sun && sun.material.uniforms) {
        sun.material.uniforms.uTime.value = elapsed;
        sun.rotation.y += delta * config.rotationSpeed;
      }

      // Update sun rays - billboard to face camera
      if (sunRays) {
        sunRays.material.uniforms.uTime.value = elapsed;
        // Make rays face camera (billboard effect)
        sunRays.quaternion.copy(camera.quaternion);
      }

      // Render with post-processing
      composer.render();
    }

    function closeViewer() {
      cancelAnimationFrame(animationId);
      // Send close message to Flutter via the FlutterChannel (mobile WebView)
      if (window.FlutterChannel) {
        window.FlutterChannel.postMessage('close');
      }
      // Also send postMessage to parent window (web iframe)
      if (window.parent && window.parent !== window) {
        window.parent.postMessage('close', '*');
      }
    }

    // Make closeViewer available globally
    window.closeViewer = closeViewer;

    // Initialize when page loads
    init();
  </script>
</body>
</html>
