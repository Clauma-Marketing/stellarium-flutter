<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>3D Star Viewer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    #canvas-container {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
    }
    canvas {
      display: block;
    }
    #close-button {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      padding: 14px 48px;
      border-radius: 30px;
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      font-size: 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      cursor: pointer;
      z-index: 100;
      transition: all 0.2s;
      -webkit-tap-highlight-color: transparent;
    }
    #close-button:hover, #close-button:active {
      background: rgba(255, 255, 255, 0.25);
      transform: translateX(-50%) scale(1.02);
    }
    #close-button svg {
      width: 20px;
      height: 20px;
    }
    #star-name {
      position: absolute;
      bottom: 130px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 24px;
      font-weight: 600;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      z-index: 100;
      text-align: center;
      max-width: 80%;
    }
    #spectral-type {
      position: absolute;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.7);
      font-size: 14px;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      z-index: 100;
    }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 16px;
      z-index: 100;
    }
    .loader {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-top: 3px solid #FFD700;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 12px;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <div id="loading">
    <div class="loader"></div>
    <div>Loading 3D Star...</div>
  </div>
  <button id="close-button" onclick="closeViewer()">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <line x1="19" y1="12" x2="5" y2="12"></line>
      <polyline points="12 19 5 12 12 5"></polyline>
    </svg>
    <span id="back-text">Back</span>
  </button>
  <div id="star-name"></div>
  <div id="spectral-type"></div>

  <!-- Three.js and required modules -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // Parse URL parameters
    const params = new URLSearchParams(window.location.search);
    const starName = params.get('name') || 'Star';
    const spectralType = params.get('spectralType') || 'G2V';
    const customCoreColor = params.get('coreColor');
    const customSurfaceColor = params.get('surfaceColor');
    const backText = params.get('backText') || 'Back';
    const vMagnitude = parseFloat(params.get('vMagnitude')) || null;
    const bMagnitude = parseFloat(params.get('bMagnitude')) || null;
    const isDouble = params.get('isDouble') === 'true';
    const distance = parseFloat(params.get('distance')) || null;

    // Parse spectral type into components: type (O-T), subclass (0-9), luminosity class (I-VII)
    function parseSpectralType(spectral) {
      const result = {
        type: 'G',
        subclass: 2,
        luminosityClass: 'V',
        luminosityNumeric: 5, // V = main sequence = 5
        fullType: spectral || 'G2V'
      };

      if (!spectral) return result;

      // Match pattern: letter + optional digit(s) + optional roman numeral
      const match = spectral.match(/^([OBAFGKMLTY])(\d)?\.?(\d)?\s*(I{1,3}|IV|V|VI|VII)?/i);
      if (match) {
        result.type = match[1].toUpperCase();
        result.subclass = match[2] ? parseInt(match[2]) : 5;
        if (match[4]) {
          result.luminosityClass = match[4].toUpperCase();
          // Convert luminosity class to numeric (lower = larger star)
          const lumMap = { 'I': 1, 'II': 2, 'III': 3, 'IV': 4, 'V': 5, 'VI': 6, 'VII': 7 };
          result.luminosityNumeric = lumMap[result.luminosityClass] || 5;
        }
      }
      return result;
    }

    const spectralData = parseSpectralType(spectralType);

    // Calculate B-V color index for more accurate colors
    const bvIndex = (bMagnitude !== null && vMagnitude !== null) ? bMagnitude - vMagnitude : null;

    // Spectral type to color mapping with B-V index refinement
    function getStarColors(spectral, bv) {
      const type = spectral.type;

      // Base colors by spectral type
      const colors = {
        'O': { core: '#9bb0ff', surface: '#aac0ff', temp: 30000 },  // Blue
        'B': { core: '#aabfff', surface: '#bbccff', temp: 20000 },  // Blue-white
        'A': { core: '#cad7ff', surface: '#dde5ff', temp: 9000 },   // White
        'F': { core: '#f8f7ff', surface: '#fffef8', temp: 7000 },   // Yellow-white
        'G': { core: '#fff4ea', surface: '#ffcc66', temp: 5500 },   // Yellow (Sun-like)
        'K': { core: '#ffd2a1', surface: '#ff9933', temp: 4500 },   // Orange
        'M': { core: '#ffcc6f', surface: '#ff6633', temp: 3500 },   // Red
        'L': { core: '#ff6633', surface: '#cc3300', temp: 2000 },   // Deep red
        'T': { core: '#cc3300', surface: '#990000', temp: 1000 },   // Brown dwarf
        'Y': { core: '#990000', surface: '#660000', temp: 500 },    // Coolest brown dwarfs
      };

      let baseColors = colors[type] || colors['G'];

      // Refine colors using B-V index if available
      if (bv !== null) {
        // B-V ranges from about -0.3 (hot blue) to +2.0 (cool red)
        // Interpolate to adjust colors
        if (bv < -0.1) {
          // Very blue stars
          baseColors = { ...baseColors, core: '#8eaaff', surface: '#9ab8ff' };
        } else if (bv > 1.5) {
          // Very red stars
          baseColors = { ...baseColors, core: '#ff8844', surface: '#ff5522' };
        }
      }

      return baseColors;
    }

    // Calculate star radius based on luminosity class
    function getStarRadius(lumClass) {
      // Luminosity class affects apparent size
      // I = Supergiant (huge), V = Main sequence (normal), VII = White dwarf (tiny)
      const radiusMap = {
        1: 2.5,   // I - Supergiant
        2: 2.0,   // II - Bright giant
        3: 1.6,   // III - Giant
        4: 1.3,   // IV - Subgiant
        5: 1.2,   // V - Main sequence (default)
        6: 0.9,   // VI - Subdwarf
        7: 0.5,   // VII - White dwarf
      };
      return radiusMap[lumClass] || 1.2;
    }

    // Calculate bloom intensity based on magnitude (brighter = lower magnitude = more bloom)
    function getBloomFromMagnitude(vMag) {
      if (vMag === null) return 1.2; // default
      // Magnitude ranges roughly from -1.5 (Sirius) to +6 (barely visible)
      // Map to bloom: brighter stars get more bloom
      const normalized = Math.max(0, Math.min(1, (6 - vMag) / 7.5));
      return 0.8 + normalized * 1.2; // Range: 0.8 to 2.0
    }

    // Calculate turbulence based on spectral type
    // Cooler stars (K, M) have more convective turbulence
    function getTurbulence(spectral) {
      const turbMap = {
        'O': 0.8,   // Hot, radiative - smooth
        'B': 0.9,
        'A': 1.0,
        'F': 1.2,
        'G': 1.5,   // Sun-like
        'K': 1.8,   // More convective
        'M': 2.2,   // Very convective, granulation
        'L': 2.5,
        'T': 2.8,
      };
      return turbMap[spectral.type] || 1.5;
    }

    // Calculate rotation speed based on spectral type
    // Hotter stars rotate faster, cooler stars slower (magnetic braking)
    function getRotationSpeed(spectral) {
      const rotMap = {
        'O': 0.25,  // Fast rotators
        'B': 0.20,
        'A': 0.15,
        'F': 0.12,
        'G': 0.10,  // Sun-like
        'K': 0.07,
        'M': 0.05,  // Slow rotators
        'L': 0.03,
        'T': 0.02,
      };
      return rotMap[spectral.type] || 0.1;
    }

    // Calculate pulse speed (surface activity)
    function getPulseSpeed(spectral) {
      const pulseMap = {
        'O': 0.15,
        'B': 0.20,
        'A': 0.25,
        'F': 0.28,
        'G': 0.30,
        'K': 0.35,
        'M': 0.45,  // More active surface
        'L': 0.50,
        'T': 0.55,
      };
      return pulseMap[spectral.type] || 0.3;
    }

    // Get ray intensity based on star properties
    function getRayIntensity(vMag, spectral) {
      let base = 0.25;
      // Brighter stars have more prominent rays
      if (vMag !== null) {
        const normalized = Math.max(0, Math.min(1, (6 - vMag) / 7.5));
        base = 0.15 + normalized * 0.25;
      }
      // Hot stars have sharper, more defined rays
      if (['O', 'B', 'A'].includes(spectral.type)) {
        base *= 1.2;
      }
      return base;
    }

    const starColors = getStarColors(spectralData, bvIndex);
    const starRadius = getStarRadius(spectralData.luminosityNumeric);

    // Build info display text
    let infoText = 'Spectral Type: ' + spectralType;
    if (vMagnitude !== null) {
      infoText += ' | Mag: ' + vMagnitude.toFixed(2);
    }
    if (distance !== null) {
      infoText += ' | ' + distance.toFixed(1) + ' ly';
    }
    if (isDouble) {
      infoText += ' | Binary';
    }

    // Display star name and info
    document.getElementById('star-name').textContent = starName;
    document.getElementById('spectral-type').textContent = infoText;
    document.getElementById('back-text').textContent = backText;

    // Config object with all calculated values
    const config = {
      coreColor: customCoreColor || starColors.core,
      surfaceColor: customSurfaceColor || starColors.surface,
      turbulence: getTurbulence(spectralData),
      pulseSpeed: getPulseSpeed(spectralData),
      rotationSpeed: getRotationSpeed(spectralData),
      bloomIntensity: getBloomFromMagnitude(vMagnitude),
      rayIntensity: getRayIntensity(vMagnitude, spectralData),
      starRadius: starRadius,
      isDouble: isDouble,
      luminosityClass: spectralData.luminosityNumeric,
      spectralType: spectralData.type,
      temperature: starColors.temp || 5500,
    };

    // ============ SHADERS (exact from your code) ============

    const sunVertexShader = `
uniform float uTime;
uniform float uPulseSpeed;
varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vPosition;

// Helper functions for Noise
vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
vec4 permute(vec4 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

// Simplex 3D Noise
float snoise(vec3 v){
  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

  vec3 i  = floor(v + dot(v, C.yyy) );
  vec3 x0 = v - i + dot(i, C.xxx) ;

  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min( g.xyz, l.zxy );
  vec3 i2 = max( g.xyz, l.zxy );

  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
  vec3 x3 = x0 - 1.0 + 3.0 * C.xxx;

  i = mod(i, 289.0 );
  vec4 p = permute( permute( permute(
             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

  float n_ = 1.0/7.0;
  vec3  ns = n_ * D.wyz - D.xzx;

  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);

  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_ );

  vec4 x = x_ *ns.x + ns.yyyy;
  vec4 y = y_ *ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);

  vec4 b0 = vec4( x.xy, y.xy );
  vec4 b1 = vec4( x.zw, y.zw );

  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));

  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

  vec3 p0 = vec3(a0.xy,h.x);
  vec3 p1 = vec3(a0.zw,h.y);
  vec3 p2 = vec3(a1.xy,h.z);
  vec3 p3 = vec3(a1.zw,h.w);

  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                dot(p2,x2), dot(p3,x3) ) );
}

void main() {
  vUv = uv;
  vNormal = normal;
  vPosition = position;

  // Dynamic Pulse Effect
  float noiseVal = snoise(vec3(position * 2.0 + uTime * uPulseSpeed));
  float displacement = noiseVal * 0.05;

  vec3 newPosition = position + normal * displacement;

  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
}
`;

    const sunFragmentShader = `
uniform float uTime;
uniform float uTurbulence;
uniform vec3 uCoreColor;
uniform vec3 uSurfaceColor;

varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vPosition;

// 3D Simplex Noise for plasma pattern
vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
vec4 permute(vec4 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

float snoise(vec3 v){
  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

  vec3 i  = floor(v + dot(v, C.yyy) );
  vec3 x0 = v - i + dot(i, C.xxx) ;

  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min( g.xyz, l.zxy );
  vec3 i2 = max( g.xyz, l.zxy );

  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
  vec3 x3 = x0 - 1.0 + 3.0 * C.xxx;

  i = mod(i, 289.0 );
  vec4 p = permute( permute( permute(
             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

  float n_ = 1.0/7.0;
  vec3  ns = n_ * D.wyz - D.xzx;

  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);

  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_ );

  vec4 x = x_ *ns.x + ns.yyyy;
  vec4 y = y_ *ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);

  vec4 b0 = vec4( x.xy, y.xy );
  vec4 b1 = vec4( x.zw, y.zw );

  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));

  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

  vec3 p0 = vec3(a0.xy,h.x);
  vec3 p1 = vec3(a0.zw,h.y);
  vec3 p2 = vec3(a1.xy,h.z);
  vec3 p3 = vec3(a1.zw,h.w);

  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                dot(p2,x2), dot(p3,x3) ) );
}

// Fractal Brownian Motion
float fbm(vec3 p) {
    float total = 0.0;
    float amplitude = 0.5;
    float frequency = 1.0;
    for(int i = 0; i < 4; i++) {
        total += snoise(p * frequency) * amplitude;
        frequency *= 2.0;
        amplitude *= 0.5;
    }
    return total;
}

void main() {
  // Moving noise coordinates
  vec3 coord = vPosition * uTurbulence + vec3(0.0, -uTime * 0.2, uTime * 0.1);
  float noiseVal = fbm(coord);

  // Remap noise from [-1, 1] to [0, 1]
  float n = (noiseVal + 1.0) * 0.5;

  // Fresnel effect for edge glowing
  vec3 viewDir = normalize(cameraPosition - vPosition);
  float fresnel = pow(1.0 - dot(viewDir, vNormal), 2.0);

  // Mix colors
  vec3 color = mix(uCoreColor, uSurfaceColor, n);

  // Add intense heat to bright spots
  float heat = smoothstep(0.4, 0.8, n);
  color += vec3(1.0, 1.0, 0.8) * heat * 1.5;

  // Edge glow
  color += uSurfaceColor * fresnel * 1.2;

  gl_FragColor = vec4(color, 1.0);
}
`;

    const raysVertexShader = `
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;

    const raysFragmentShader = `
uniform float uTime;
uniform vec3 uColor;
uniform float uIntensity;
varying vec2 vUv;

void main() {
  vec2 uv = vUv - 0.5;
  // Convert to polar coordinates
  float dist = length(uv) * 2.0;
  float angle = atan(uv.y, uv.x);

  // Create thin rays using high exponents on sine waves
  float r1 = sin(angle * 30.0 + uTime * 0.1);
  r1 = pow(max(0.0, r1), 40.0);

  float r2 = sin(angle * 47.0 - uTime * 0.15);
  r2 = pow(max(0.0, r2), 30.0);

  float rays = r1 + r2 * 0.6;

  // Radial attenuation (fade out at edges)
  float fade = 1.0 - smoothstep(0.0, 0.8, dist);
  fade = pow(fade, 2.0);

  // Combine
  float alpha = rays * fade * uIntensity;

  gl_FragColor = vec4(uColor, alpha);
}
`;

    // ============ Three.js Setup ============

    let scene, camera, renderer, controls, composer;
    let sun, sunRays;
    let clock = new THREE.Clock();
    let animationId;

    function init() {
      const container = document.getElementById('canvas-container');

      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      // Camera - positioned based on star size for optimal viewing
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      const cameraDistance = 5 + config.starRadius * 2.5;
      camera.position.set(0, 0, cameraDistance);

      // Renderer with Reinhard tone mapping
      renderer = new THREE.WebGLRenderer({ antialias: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.toneMapping = THREE.ReinhardToneMapping;
      container.appendChild(renderer.domElement);

      // OrbitControls - scale distances with star size
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enablePan = false;
      controls.minDistance = 2 + config.starRadius * 1.5;
      controls.maxDistance = 8 + config.starRadius * 6;
      controls.zoomSpeed = 0.5;
      controls.rotateSpeed = 0.5;
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Create objects
      createBackgroundStars();
      createSun();
      createSunRays();

      // Post-processing with Bloom
      setupPostProcessing();

      // Event listeners
      window.addEventListener('resize', onWindowResize, false);

      // Hide loading
      document.getElementById('loading').style.display = 'none';

      // Start animation
      animate();
    }

    function createBackgroundStars() {
      // Matching drei Stars: radius=300, depth=50, count=5000
      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      const sizes = [];

      for (let i = 0; i < 5000; i++) {
        // Distributed in a shell between radius 250-350
        const radius = 250 + Math.random() * 100;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);

        vertices.push(
          radius * Math.sin(phi) * Math.cos(theta),
          radius * Math.sin(phi) * Math.sin(theta),
          radius * Math.cos(phi)
        );

        // Varying sizes (factor=4 in drei)
        sizes.push(Math.random() * 4 + 0.5);
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

      // Custom shader for stars with size attenuation and fade
      const starMaterial = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 }
        },
        vertexShader: `
          attribute float size;
          varying float vSize;
          void main() {
            vSize = size;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = size * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          varying float vSize;
          void main() {
            float dist = length(gl_PointCoord - vec2(0.5));
            if (dist > 0.5) discard;
            float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
            gl_FragColor = vec4(1.0, 1.0, 1.0, alpha * 0.8);
          }
        `,
        transparent: true,
        depthWrite: false
      });

      const stars = new THREE.Points(geometry, starMaterial);
      scene.add(stars);
    }

    function createSun() {
      // Use dynamic radius based on luminosity class
      const geometry = new THREE.SphereGeometry(config.starRadius, 64, 64);

      const material = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uTurbulence: { value: config.turbulence },
          uPulseSpeed: { value: config.pulseSpeed },
          uCoreColor: { value: new THREE.Color(config.coreColor) },
          uSurfaceColor: { value: new THREE.Color(config.surfaceColor) }
        },
        vertexShader: sunVertexShader,
        fragmentShader: sunFragmentShader,
        side: THREE.DoubleSide
      });

      sun = new THREE.Mesh(geometry, material);
      scene.add(sun);

      // Create binary companion if this is a double star
      if (config.isDouble) {
        createCompanionStar();
      }
    }

    let companionStar = null;
    let companionOrbitAngle = 0;

    function createCompanionStar() {
      // Companion star is typically smaller and dimmer
      // Random variation in size (50-80% of primary)
      const companionRadius = config.starRadius * (0.5 + Math.random() * 0.3);

      // Slightly different color (could be cooler or hotter)
      const colorVariation = Math.random() > 0.5 ? 1 : -1;
      const spectralTypes = ['O', 'B', 'A', 'F', 'G', 'K', 'M'];
      const currentIdx = spectralTypes.indexOf(config.spectralType);
      const companionIdx = Math.max(0, Math.min(6, currentIdx + colorVariation));
      const companionType = spectralTypes[companionIdx];

      const companionColors = {
        'O': { core: '#9bb0ff', surface: '#aac0ff' },
        'B': { core: '#aabfff', surface: '#bbccff' },
        'A': { core: '#cad7ff', surface: '#dde5ff' },
        'F': { core: '#f8f7ff', surface: '#fffef8' },
        'G': { core: '#fff4ea', surface: '#ffcc66' },
        'K': { core: '#ffd2a1', surface: '#ff9933' },
        'M': { core: '#ffcc6f', surface: '#ff6633' },
      };

      const colors = companionColors[companionType] || companionColors['K'];

      const geometry = new THREE.SphereGeometry(companionRadius, 48, 48);

      const material = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uTurbulence: { value: config.turbulence * 0.8 },
          uPulseSpeed: { value: config.pulseSpeed * 1.2 },
          uCoreColor: { value: new THREE.Color(colors.core) },
          uSurfaceColor: { value: new THREE.Color(colors.surface) }
        },
        vertexShader: sunVertexShader,
        fragmentShader: sunFragmentShader,
        side: THREE.DoubleSide
      });

      companionStar = new THREE.Mesh(geometry, material);

      // Position companion at orbital distance
      const orbitRadius = config.starRadius * 3 + companionRadius * 2;
      companionStar.position.x = orbitRadius;

      scene.add(companionStar);
    }

    function createSunRays() {
      // Billboard plane for sun rays - scale with star size
      const raySize = 5 * config.starRadius;
      const geometry = new THREE.PlaneGeometry(raySize, raySize);

      const material = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uColor: { value: new THREE.Color(config.surfaceColor) },
          uIntensity: { value: config.rayIntensity }
        },
        vertexShader: raysVertexShader,
        fragmentShader: raysFragmentShader,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        side: THREE.DoubleSide
      });

      sunRays = new THREE.Mesh(geometry, material);
      scene.add(sunRays);
    }

    function setupPostProcessing() {
      composer = new EffectComposer(renderer);

      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);

      // Bloom pass (matching your React config)
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        config.bloomIntensity,  // intensity
        0.8,                     // radius
        0.2                      // threshold (luminanceThreshold)
      );
      composer.addPass(bloomPass);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      animationId = requestAnimationFrame(animate);

      const delta = clock.getDelta();
      const elapsed = clock.getElapsedTime();

      // Update controls
      controls.update();

      // Update sun uniforms
      if (sun && sun.material.uniforms) {
        sun.material.uniforms.uTime.value = elapsed;
        sun.rotation.y += delta * config.rotationSpeed;
      }

      // Update companion star (binary system animation)
      if (companionStar && companionStar.material.uniforms) {
        companionStar.material.uniforms.uTime.value = elapsed;
        companionStar.rotation.y += delta * config.rotationSpeed * 1.3;

        // Orbit around primary star
        companionOrbitAngle += delta * 0.15; // Slow orbit
        const orbitRadius = config.starRadius * 3 + 1;
        companionStar.position.x = Math.cos(companionOrbitAngle) * orbitRadius;
        companionStar.position.z = Math.sin(companionOrbitAngle) * orbitRadius;
        // Slight vertical oscillation for 3D effect
        companionStar.position.y = Math.sin(companionOrbitAngle * 2) * 0.3;
      }

      // Update sun rays - billboard to face camera
      if (sunRays) {
        sunRays.material.uniforms.uTime.value = elapsed;
        // Make rays face camera (billboard effect)
        sunRays.quaternion.copy(camera.quaternion);
      }

      // Render with post-processing
      composer.render();
    }

    function closeViewer() {
      cancelAnimationFrame(animationId);
      // Send close message to Flutter via the FlutterChannel (mobile WebView)
      if (window.FlutterChannel) {
        window.FlutterChannel.postMessage('close');
      }
      // Also send postMessage to parent window (web iframe)
      if (window.parent && window.parent !== window) {
        window.parent.postMessage('close', '*');
      }
    }

    // Make closeViewer available globally
    window.closeViewer = closeViewer;

    // Initialize when page loads
    init();
  </script>
</body>
</html>
